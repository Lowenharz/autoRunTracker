# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_py_interop_metrics')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_py_interop_metrics')
    _py_interop_metrics = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_py_interop_metrics', [dirname(__file__)])
        except ImportError:
            import _py_interop_metrics
            return _py_interop_metrics
        if fp is not None:
            try:
                _mod = imp.load_module('_py_interop_metrics', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _py_interop_metrics = swig_import_helper()
    del swig_import_helper
else:
    import _py_interop_metrics
del _swig_python_version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _py_interop_metrics.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self):
        return _py_interop_metrics.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _py_interop_metrics.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _py_interop_metrics.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _py_interop_metrics.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _py_interop_metrics.SwigPyIterator_equal(self, x)

    def copy(self):
        return _py_interop_metrics.SwigPyIterator_copy(self)

    def next(self):
        return _py_interop_metrics.SwigPyIterator_next(self)

    def __next__(self):
        return _py_interop_metrics.SwigPyIterator___next__(self)

    def previous(self):
        return _py_interop_metrics.SwigPyIterator_previous(self)

    def advance(self, n):
        return _py_interop_metrics.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _py_interop_metrics.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _py_interop_metrics.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _py_interop_metrics.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _py_interop_metrics.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _py_interop_metrics.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _py_interop_metrics.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _py_interop_metrics.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

import interop.py_interop_run
class index_out_of_bounds_exception(interop.py_interop_run.base_exception):
    __swig_setmethods__ = {}
    for _s in [interop.py_interop_run.base_exception]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, index_out_of_bounds_exception, name, value)
    __swig_getmethods__ = {}
    for _s in [interop.py_interop_run.base_exception]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, index_out_of_bounds_exception, name)
    __repr__ = _swig_repr

    def __init__(self, mesg):
        this = _py_interop_metrics.new_index_out_of_bounds_exception(mesg)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __str__(self):
        return _py_interop_metrics.index_out_of_bounds_exception___str__(self)
    __swig_destroy__ = _py_interop_metrics.delete_index_out_of_bounds_exception
    __del__ = lambda self: None
index_out_of_bounds_exception_swigregister = _py_interop_metrics.index_out_of_bounds_exception_swigregister
index_out_of_bounds_exception_swigregister(index_out_of_bounds_exception)

class csharp_date_time(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, csharp_date_time, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, csharp_date_time, name)
    __repr__ = _swig_repr

    def __init__(self, v=0):
        this = _py_interop_metrics.new_csharp_date_time(v)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    if _newclass:
        to_unix = staticmethod(_py_interop_metrics.csharp_date_time_to_unix)
    else:
        to_unix = _py_interop_metrics.csharp_date_time_to_unix
    if _newclass:
        to_seconds = staticmethod(_py_interop_metrics.csharp_date_time_to_seconds)
    else:
        to_seconds = _py_interop_metrics.csharp_date_time_to_seconds
    if _newclass:
        to_csharp = staticmethod(_py_interop_metrics.csharp_date_time_to_csharp)
    else:
        to_csharp = _py_interop_metrics.csharp_date_time_to_csharp
    __swig_setmethods__["value"] = _py_interop_metrics.csharp_date_time_value_set
    __swig_getmethods__["value"] = _py_interop_metrics.csharp_date_time_value_get
    if _newclass:
        value = _swig_property(_py_interop_metrics.csharp_date_time_value_get, _py_interop_metrics.csharp_date_time_value_set)

    def to_int(self):
        return _py_interop_metrics.csharp_date_time_to_int(self)

    def to_binary(self):
        return _py_interop_metrics.csharp_date_time_to_binary(self)

    def __eq__(self, other):
        return _py_interop_metrics.csharp_date_time___eq__(self, other)
    __swig_destroy__ = _py_interop_metrics.delete_csharp_date_time
    __del__ = lambda self: None
csharp_date_time_swigregister = _py_interop_metrics.csharp_date_time_swigregister
csharp_date_time_swigregister(csharp_date_time)

def csharp_date_time_to_unix(*args):
    return _py_interop_metrics.csharp_date_time_to_unix(*args)
csharp_date_time_to_unix = _py_interop_metrics.csharp_date_time_to_unix

def csharp_date_time_to_seconds(*args):
    return _py_interop_metrics.csharp_date_time_to_seconds(*args)
csharp_date_time_to_seconds = _py_interop_metrics.csharp_date_time_to_seconds

def csharp_date_time_to_csharp(uval):
    return _py_interop_metrics.csharp_date_time_to_csharp(uval)
csharp_date_time_to_csharp = _py_interop_metrics.csharp_date_time_to_csharp

class empty_header(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, empty_header, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, empty_header, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _py_interop_metrics.new_empty_header()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _py_interop_metrics.delete_empty_header
    __del__ = lambda self: None
empty_header_swigregister = _py_interop_metrics.empty_header_swigregister
empty_header_swigregister(empty_header)

class base_metric_header(empty_header):
    __swig_setmethods__ = {}
    for _s in [empty_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, base_metric_header, name, value)
    __swig_getmethods__ = {}
    for _s in [empty_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, base_metric_header, name)
    __repr__ = _swig_repr
    if _newclass:
        default_header = staticmethod(_py_interop_metrics.base_metric_header_default_header)
    else:
        default_header = _py_interop_metrics.base_metric_header_default_header

    def __init__(self):
        this = _py_interop_metrics.new_base_metric_header()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _py_interop_metrics.delete_base_metric_header
    __del__ = lambda self: None
base_metric_header_swigregister = _py_interop_metrics.base_metric_header_swigregister
base_metric_header_swigregister(base_metric_header)

def base_metric_header_default_header():
    return _py_interop_metrics.base_metric_header_default_header()
base_metric_header_default_header = _py_interop_metrics.base_metric_header_default_header

class empty_metric(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, empty_metric, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, empty_metric, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _py_interop_metrics.new_empty_metric()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _py_interop_metrics.delete_empty_metric
    __del__ = lambda self: None
empty_metric_swigregister = _py_interop_metrics.empty_metric_swigregister
empty_metric_swigregister(empty_metric)

class base_metric(empty_metric):
    __swig_setmethods__ = {}
    for _s in [empty_metric]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, base_metric, name, value)
    __swig_getmethods__ = {}
    for _s in [empty_metric]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, base_metric, name)
    __repr__ = _swig_repr
    LANE_BIT_COUNT = _py_interop_metrics.base_metric_LANE_BIT_COUNT
    TILE_BIT_COUNT = _py_interop_metrics.base_metric_TILE_BIT_COUNT
    CYCLE_BIT_COUNT = _py_interop_metrics.base_metric_CYCLE_BIT_COUNT
    READ_BIT_COUNT = _py_interop_metrics.base_metric_READ_BIT_COUNT
    RESERVED_BIT_COUNT = _py_interop_metrics.base_metric_RESERVED_BIT_COUNT
    READ_BIT_SHIFT = _py_interop_metrics.base_metric_READ_BIT_SHIFT
    CYCLE_BIT_SHIFT = _py_interop_metrics.base_metric_CYCLE_BIT_SHIFT
    EVENT_BIT_SHIFT = _py_interop_metrics.base_metric_EVENT_BIT_SHIFT
    TILE_BIT_SHIFT = _py_interop_metrics.base_metric_TILE_BIT_SHIFT
    LANE_BIT_SHIFT = _py_interop_metrics.base_metric_LANE_BIT_SHIFT

    def __init__(self, lane=0, tile=0):
        this = _py_interop_metrics.new_base_metric(lane, tile)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def set_base(self, lane, tile):
        return _py_interop_metrics.base_metric_set_base(self, lane, tile)

    def id(self):
        return _py_interop_metrics.base_metric_id(self)

    def tile_hash(self):
        return _py_interop_metrics.base_metric_tile_hash(self)
    if _newclass:
        create_id = staticmethod(_py_interop_metrics.base_metric_create_id)
    else:
        create_id = _py_interop_metrics.base_metric_create_id
    if _newclass:
        lane_from_id = staticmethod(_py_interop_metrics.base_metric_lane_from_id)
    else:
        lane_from_id = _py_interop_metrics.base_metric_lane_from_id
    if _newclass:
        tile_hash_from_id = staticmethod(_py_interop_metrics.base_metric_tile_hash_from_id)
    else:
        tile_hash_from_id = _py_interop_metrics.base_metric_tile_hash_from_id
    if _newclass:
        tile_from_id = staticmethod(_py_interop_metrics.base_metric_tile_from_id)
    else:
        tile_from_id = _py_interop_metrics.base_metric_tile_from_id

    def lane(self):
        return _py_interop_metrics.base_metric_lane(self)

    def tile(self):
        return _py_interop_metrics.base_metric_tile(self)

    def number(self, arg2):
        return _py_interop_metrics.base_metric_number(self, arg2)

    def section(self, method):
        return _py_interop_metrics.base_metric_section(self, method)

    def surface(self, method):
        return _py_interop_metrics.base_metric_surface(self, method)

    def swath(self, method):
        return _py_interop_metrics.base_metric_swath(self, method)

    def phyiscalLocationIndex(self, method, section_per_lane, tile_count, swath_count, all_surfaces):
        return _py_interop_metrics.base_metric_phyiscalLocationIndex(self, method, section_per_lane, tile_count, swath_count, all_surfaces)

    def phyiscalLocationColumn(self, method, swath_count, all_surfaces):
        return _py_interop_metrics.base_metric_phyiscalLocationColumn(self, method, swath_count, all_surfaces)

    def phyiscalLocationRow(self, method, section_per_lane, tile_count):
        return _py_interop_metrics.base_metric_phyiscalLocationRow(self, method, section_per_lane, tile_count)

    def physical_location_index(self, method, section_per_lane, tile_count, swath_count, all_surfaces):
        return _py_interop_metrics.base_metric_physical_location_index(self, method, section_per_lane, tile_count, swath_count, all_surfaces)

    def physical_location_column(self, method, swath_count, all_surfaces):
        return _py_interop_metrics.base_metric_physical_location_column(self, method, swath_count, all_surfaces)

    def physical_location_row(self, method, section_per_lane, tile_count):
        return _py_interop_metrics.base_metric_physical_location_row(self, method, section_per_lane, tile_count)
    if _newclass:
        suffix = staticmethod(_py_interop_metrics.base_metric_suffix)
    else:
        suffix = _py_interop_metrics.base_metric_suffix
    __swig_destroy__ = _py_interop_metrics.delete_base_metric
    __del__ = lambda self: None
base_metric_swigregister = _py_interop_metrics.base_metric_swigregister
base_metric_swigregister(base_metric)

def base_metric_create_id(lane, tile, arg3=0):
    return _py_interop_metrics.base_metric_create_id(lane, tile, arg3)
base_metric_create_id = _py_interop_metrics.base_metric_create_id

def base_metric_lane_from_id(id):
    return _py_interop_metrics.base_metric_lane_from_id(id)
base_metric_lane_from_id = _py_interop_metrics.base_metric_lane_from_id

def base_metric_tile_hash_from_id(id):
    return _py_interop_metrics.base_metric_tile_hash_from_id(id)
base_metric_tile_hash_from_id = _py_interop_metrics.base_metric_tile_hash_from_id

def base_metric_tile_from_id(id):
    return _py_interop_metrics.base_metric_tile_from_id(id)
base_metric_tile_from_id = _py_interop_metrics.base_metric_tile_from_id

def base_metric_suffix():
    return _py_interop_metrics.base_metric_suffix()
base_metric_suffix = _py_interop_metrics.base_metric_suffix

class base_cycle_metric_header(empty_header):
    __swig_setmethods__ = {}
    for _s in [empty_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, base_cycle_metric_header, name, value)
    __swig_getmethods__ = {}
    for _s in [empty_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, base_cycle_metric_header, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _py_interop_metrics.new_base_cycle_metric_header()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    if _newclass:
        default_header = staticmethod(_py_interop_metrics.base_cycle_metric_header_default_header)
    else:
        default_header = _py_interop_metrics.base_cycle_metric_header_default_header

    def max_cycle(self):
        return _py_interop_metrics.base_cycle_metric_header_max_cycle(self)

    def clear(self):
        return _py_interop_metrics.base_cycle_metric_header_clear(self)
    __swig_destroy__ = _py_interop_metrics.delete_base_cycle_metric_header
    __del__ = lambda self: None
base_cycle_metric_header_swigregister = _py_interop_metrics.base_cycle_metric_header_swigregister
base_cycle_metric_header_swigregister(base_cycle_metric_header)

def base_cycle_metric_header_default_header():
    return _py_interop_metrics.base_cycle_metric_header_default_header()
base_cycle_metric_header_default_header = _py_interop_metrics.base_cycle_metric_header_default_header

class base_cycle_metric(base_metric):
    __swig_setmethods__ = {}
    for _s in [base_metric]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, base_cycle_metric, name, value)
    __swig_getmethods__ = {}
    for _s in [base_metric]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, base_cycle_metric, name)
    __repr__ = _swig_repr

    def __init__(self, lane=0, tile=0, cycle=0):
        this = _py_interop_metrics.new_base_cycle_metric(lane, tile, cycle)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def set_base(self, *args):
        return _py_interop_metrics.base_cycle_metric_set_base(self, *args)

    def cycle(self):
        return _py_interop_metrics.base_cycle_metric_cycle(self)

    def id(self):
        return _py_interop_metrics.base_cycle_metric_id(self)

    def cycle_hash(self):
        return _py_interop_metrics.base_cycle_metric_cycle_hash(self)
    if _newclass:
        cycle_from_id = staticmethod(_py_interop_metrics.base_cycle_metric_cycle_from_id)
    else:
        cycle_from_id = _py_interop_metrics.base_cycle_metric_cycle_from_id
    if _newclass:
        reserved_from_id = staticmethod(_py_interop_metrics.base_cycle_metric_reserved_from_id)
    else:
        reserved_from_id = _py_interop_metrics.base_cycle_metric_reserved_from_id
    if _newclass:
        create_id = staticmethod(_py_interop_metrics.base_cycle_metric_create_id)
    else:
        create_id = _py_interop_metrics.base_cycle_metric_create_id
    __swig_destroy__ = _py_interop_metrics.delete_base_cycle_metric
    __del__ = lambda self: None
base_cycle_metric_swigregister = _py_interop_metrics.base_cycle_metric_swigregister
base_cycle_metric_swigregister(base_cycle_metric)

def base_cycle_metric_cycle_from_id(id):
    return _py_interop_metrics.base_cycle_metric_cycle_from_id(id)
base_cycle_metric_cycle_from_id = _py_interop_metrics.base_cycle_metric_cycle_from_id

def base_cycle_metric_reserved_from_id(id):
    return _py_interop_metrics.base_cycle_metric_reserved_from_id(id)
base_cycle_metric_reserved_from_id = _py_interop_metrics.base_cycle_metric_reserved_from_id

def base_cycle_metric_create_id(lane, tile, cycle):
    return _py_interop_metrics.base_cycle_metric_create_id(lane, tile, cycle)
base_cycle_metric_create_id = _py_interop_metrics.base_cycle_metric_create_id

class base_read_metric_header(empty_header):
    __swig_setmethods__ = {}
    for _s in [empty_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, base_read_metric_header, name, value)
    __swig_getmethods__ = {}
    for _s in [empty_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, base_read_metric_header, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _py_interop_metrics.new_base_read_metric_header()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    if _newclass:
        default_header = staticmethod(_py_interop_metrics.base_read_metric_header_default_header)
    else:
        default_header = _py_interop_metrics.base_read_metric_header_default_header
    __swig_destroy__ = _py_interop_metrics.delete_base_read_metric_header
    __del__ = lambda self: None
base_read_metric_header_swigregister = _py_interop_metrics.base_read_metric_header_swigregister
base_read_metric_header_swigregister(base_read_metric_header)

def base_read_metric_header_default_header():
    return _py_interop_metrics.base_read_metric_header_default_header()
base_read_metric_header_default_header = _py_interop_metrics.base_read_metric_header_default_header

class base_read_metric(base_metric):
    __swig_setmethods__ = {}
    for _s in [base_metric]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, base_read_metric, name, value)
    __swig_getmethods__ = {}
    for _s in [base_metric]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, base_read_metric, name)
    __repr__ = _swig_repr

    def __init__(self, lane, tile, read):
        this = _py_interop_metrics.new_base_read_metric(lane, tile, read)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def set_base(self, *args):
        return _py_interop_metrics.base_read_metric_set_base(self, *args)

    def read(self):
        return _py_interop_metrics.base_read_metric_read(self)

    def id(self):
        return _py_interop_metrics.base_read_metric_id(self)
    if _newclass:
        create_id = staticmethod(_py_interop_metrics.base_read_metric_create_id)
    else:
        create_id = _py_interop_metrics.base_read_metric_create_id
    if _newclass:
        read_from_id = staticmethod(_py_interop_metrics.base_read_metric_read_from_id)
    else:
        read_from_id = _py_interop_metrics.base_read_metric_read_from_id
    __swig_destroy__ = _py_interop_metrics.delete_base_read_metric
    __del__ = lambda self: None
base_read_metric_swigregister = _py_interop_metrics.base_read_metric_swigregister
base_read_metric_swigregister(base_read_metric)

def base_read_metric_create_id(lane, tile, read):
    return _py_interop_metrics.base_read_metric_create_id(lane, tile, read)
base_read_metric_create_id = _py_interop_metrics.base_read_metric_create_id

def base_read_metric_read_from_id(id):
    return _py_interop_metrics.base_read_metric_read_from_id(id)
base_read_metric_read_from_id = _py_interop_metrics.base_read_metric_read_from_id

class base_static_run_metric_header(empty_header):
    __swig_setmethods__ = {}
    for _s in [empty_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, base_static_run_metric_header, name, value)
    __swig_getmethods__ = {}
    for _s in [empty_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, base_static_run_metric_header, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _py_interop_metrics.new_base_static_run_metric_header()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _py_interop_metrics.delete_base_static_run_metric_header
    __del__ = lambda self: None
base_static_run_metric_header_swigregister = _py_interop_metrics.base_static_run_metric_header_swigregister
base_static_run_metric_header_swigregister(base_static_run_metric_header)

class base_static_run_metric(empty_metric):
    __swig_setmethods__ = {}
    for _s in [empty_metric]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, base_static_run_metric, name, value)
    __swig_getmethods__ = {}
    for _s in [empty_metric]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, base_static_run_metric, name)
    __repr__ = _swig_repr
    CHANNEL_BIT_SHIFT = _py_interop_metrics.base_static_run_metric_CHANNEL_BIT_SHIFT
    DISTORTION_BIT_SHIFT = _py_interop_metrics.base_static_run_metric_DISTORTION_BIT_SHIFT

    def __init__(self, camera, channel, distortion_type):
        this = _py_interop_metrics.new_base_static_run_metric(camera, channel, distortion_type)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def set_base(self, camera, channel, distortion_type):
        return _py_interop_metrics.base_static_run_metric_set_base(self, camera, channel, distortion_type)
    if _newclass:
        suffix = staticmethod(_py_interop_metrics.base_static_run_metric_suffix)
    else:
        suffix = _py_interop_metrics.base_static_run_metric_suffix

    def id(self):
        return _py_interop_metrics.base_static_run_metric_id(self)
    if _newclass:
        create_id = staticmethod(_py_interop_metrics.base_static_run_metric_create_id)
    else:
        create_id = _py_interop_metrics.base_static_run_metric_create_id

    def camera(self):
        return _py_interop_metrics.base_static_run_metric_camera(self)

    def channel(self):
        return _py_interop_metrics.base_static_run_metric_channel(self)

    def distortion_type(self):
        return _py_interop_metrics.base_static_run_metric_distortion_type(self)

    def lane(self):
        return _py_interop_metrics.base_static_run_metric_lane(self)

    def tile(self):
        return _py_interop_metrics.base_static_run_metric_tile(self)
    __swig_destroy__ = _py_interop_metrics.delete_base_static_run_metric
    __del__ = lambda self: None
base_static_run_metric_swigregister = _py_interop_metrics.base_static_run_metric_swigregister
base_static_run_metric_swigregister(base_static_run_metric)

def base_static_run_metric_suffix():
    return _py_interop_metrics.base_static_run_metric_suffix()
base_static_run_metric_suffix = _py_interop_metrics.base_static_run_metric_suffix

def base_static_run_metric_create_id(camera, channel, distortion_type):
    return _py_interop_metrics.base_static_run_metric_create_id(camera, channel, distortion_type)
base_static_run_metric_create_id = _py_interop_metrics.base_static_run_metric_create_id

class base_event_metric_header(empty_header):
    __swig_setmethods__ = {}
    for _s in [empty_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, base_event_metric_header, name, value)
    __swig_getmethods__ = {}
    for _s in [empty_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, base_event_metric_header, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _py_interop_metrics.new_base_event_metric_header()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    if _newclass:
        default_header = staticmethod(_py_interop_metrics.base_event_metric_header_default_header)
    else:
        default_header = _py_interop_metrics.base_event_metric_header_default_header

    def max_cycle(self):
        return _py_interop_metrics.base_event_metric_header_max_cycle(self)

    def clear(self):
        return _py_interop_metrics.base_event_metric_header_clear(self)
    __swig_destroy__ = _py_interop_metrics.delete_base_event_metric_header
    __del__ = lambda self: None
base_event_metric_header_swigregister = _py_interop_metrics.base_event_metric_header_swigregister
base_event_metric_header_swigregister(base_event_metric_header)

def base_event_metric_header_default_header():
    return _py_interop_metrics.base_event_metric_header_default_header()
base_event_metric_header_default_header = _py_interop_metrics.base_event_metric_header_default_header

class base_event_metric(base_cycle_metric):
    __swig_setmethods__ = {}
    for _s in [base_cycle_metric]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, base_event_metric, name, value)
    __swig_getmethods__ = {}
    for _s in [base_cycle_metric]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, base_event_metric, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _py_interop_metrics.new_base_event_metric(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def set_base(self, *args):
        return _py_interop_metrics.base_event_metric_set_base(self, *args)

    def event_type_long(self):
        return _py_interop_metrics.base_event_metric_event_type_long(self)

    def event_type(self, *args):
        return _py_interop_metrics.base_event_metric_event_type(self, *args)

    def id(self):
        return _py_interop_metrics.base_event_metric_id(self)
    if _newclass:
        create_id = staticmethod(_py_interop_metrics.base_event_metric_create_id)
    else:
        create_id = _py_interop_metrics.base_event_metric_create_id
    __swig_destroy__ = _py_interop_metrics.delete_base_event_metric
    __del__ = lambda self: None
base_event_metric_swigregister = _py_interop_metrics.base_event_metric_swigregister
base_event_metric_swigregister(base_event_metric)

def base_event_metric_create_id(lane, tile, cycle, event_type):
    return _py_interop_metrics.base_event_metric_create_id(lane, tile, cycle, event_type)
base_event_metric_create_id = _py_interop_metrics.base_event_metric_create_id

class point2d(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, point2d, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, point2d, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _py_interop_metrics.new_point2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def x(self):
        return _py_interop_metrics.point2d_x(self)

    def y(self):
        return _py_interop_metrics.point2d_y(self)
    __swig_destroy__ = _py_interop_metrics.delete_point2d
    __del__ = lambda self: None
point2d_swigregister = _py_interop_metrics.point2d_swigregister
point2d_swigregister(point2d)

class index_info_vector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, index_info_vector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, index_info_vector, name)
    __repr__ = _swig_repr
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _py_interop_metrics.index_info_vector___nonzero__(self)

    def __bool__(self):
        return _py_interop_metrics.index_info_vector___bool__(self)

    def __len__(self):
        return _py_interop_metrics.index_info_vector___len__(self)

    def __getslice__(self, i, j):
        return _py_interop_metrics.index_info_vector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _py_interop_metrics.index_info_vector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _py_interop_metrics.index_info_vector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _py_interop_metrics.index_info_vector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _py_interop_metrics.index_info_vector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _py_interop_metrics.index_info_vector___setitem__(self, *args)

    def pop(self):
        return _py_interop_metrics.index_info_vector_pop(self)

    def append(self, x):
        return _py_interop_metrics.index_info_vector_append(self, x)

    def empty(self):
        return _py_interop_metrics.index_info_vector_empty(self)

    def size(self):
        return _py_interop_metrics.index_info_vector_size(self)

    def swap(self, v):
        return _py_interop_metrics.index_info_vector_swap(self, v)

    def rbegin(self):
        return _py_interop_metrics.index_info_vector_rbegin(self)

    def rend(self):
        return _py_interop_metrics.index_info_vector_rend(self)

    def clear(self):
        return _py_interop_metrics.index_info_vector_clear(self)

    def get_allocator(self):
        return _py_interop_metrics.index_info_vector_get_allocator(self)

    def pop_back(self):
        return _py_interop_metrics.index_info_vector_pop_back(self)

    def erase(self, *args):
        return _py_interop_metrics.index_info_vector_erase(self, *args)

    def __init__(self, *args):
        this = _py_interop_metrics.new_index_info_vector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _py_interop_metrics.index_info_vector_push_back(self, x)

    def front(self):
        return _py_interop_metrics.index_info_vector_front(self)

    def back(self):
        return _py_interop_metrics.index_info_vector_back(self)

    def assign(self, n, x):
        return _py_interop_metrics.index_info_vector_assign(self, n, x)

    def resize(self, *args):
        return _py_interop_metrics.index_info_vector_resize(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.index_info_vector_insert(self, *args)

    def reserve(self, n):
        return _py_interop_metrics.index_info_vector_reserve(self, n)

    def capacity(self):
        return _py_interop_metrics.index_info_vector_capacity(self)
    __swig_destroy__ = _py_interop_metrics.delete_index_info_vector
    __del__ = lambda self: None
index_info_vector_swigregister = _py_interop_metrics.index_info_vector_swigregister
index_info_vector_swigregister(index_info_vector)

class tile_metric_map(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, tile_metric_map, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, tile_metric_map, name)
    __repr__ = _swig_repr
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _py_interop_metrics.tile_metric_map___nonzero__(self)

    def __bool__(self):
        return _py_interop_metrics.tile_metric_map___bool__(self)

    def __len__(self):
        return _py_interop_metrics.tile_metric_map___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        return _py_interop_metrics.tile_metric_map___getitem__(self, key)

    def __delitem__(self, key):
        return _py_interop_metrics.tile_metric_map___delitem__(self, key)

    def has_key(self, key):
        return _py_interop_metrics.tile_metric_map_has_key(self, key)

    def keys(self):
        return _py_interop_metrics.tile_metric_map_keys(self)

    def values(self):
        return _py_interop_metrics.tile_metric_map_values(self)

    def items(self):
        return _py_interop_metrics.tile_metric_map_items(self)

    def __contains__(self, key):
        return _py_interop_metrics.tile_metric_map___contains__(self, key)

    def key_iterator(self):
        return _py_interop_metrics.tile_metric_map_key_iterator(self)

    def value_iterator(self):
        return _py_interop_metrics.tile_metric_map_value_iterator(self)

    def __setitem__(self, *args):
        return _py_interop_metrics.tile_metric_map___setitem__(self, *args)

    def asdict(self):
        return _py_interop_metrics.tile_metric_map_asdict(self)

    def __init__(self, *args):
        this = _py_interop_metrics.new_tile_metric_map(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def empty(self):
        return _py_interop_metrics.tile_metric_map_empty(self)

    def size(self):
        return _py_interop_metrics.tile_metric_map_size(self)

    def swap(self, v):
        return _py_interop_metrics.tile_metric_map_swap(self, v)

    def rbegin(self):
        return _py_interop_metrics.tile_metric_map_rbegin(self)

    def rend(self):
        return _py_interop_metrics.tile_metric_map_rend(self)

    def clear(self):
        return _py_interop_metrics.tile_metric_map_clear(self)

    def get_allocator(self):
        return _py_interop_metrics.tile_metric_map_get_allocator(self)

    def count(self, x):
        return _py_interop_metrics.tile_metric_map_count(self, x)

    def erase(self, *args):
        return _py_interop_metrics.tile_metric_map_erase(self, *args)

    def find(self, x):
        return _py_interop_metrics.tile_metric_map_find(self, x)

    def lower_bound(self, x):
        return _py_interop_metrics.tile_metric_map_lower_bound(self, x)

    def upper_bound(self, x):
        return _py_interop_metrics.tile_metric_map_upper_bound(self, x)
    __swig_destroy__ = _py_interop_metrics.delete_tile_metric_map
    __del__ = lambda self: None
tile_metric_map_swigregister = _py_interop_metrics.tile_metric_map_swigregister
tile_metric_map_swigregister(tile_metric_map)

class cycle_metric_map(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cycle_metric_map, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cycle_metric_map, name)
    __repr__ = _swig_repr
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _py_interop_metrics.cycle_metric_map___nonzero__(self)

    def __bool__(self):
        return _py_interop_metrics.cycle_metric_map___bool__(self)

    def __len__(self):
        return _py_interop_metrics.cycle_metric_map___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        return _py_interop_metrics.cycle_metric_map___getitem__(self, key)

    def __delitem__(self, key):
        return _py_interop_metrics.cycle_metric_map___delitem__(self, key)

    def has_key(self, key):
        return _py_interop_metrics.cycle_metric_map_has_key(self, key)

    def keys(self):
        return _py_interop_metrics.cycle_metric_map_keys(self)

    def values(self):
        return _py_interop_metrics.cycle_metric_map_values(self)

    def items(self):
        return _py_interop_metrics.cycle_metric_map_items(self)

    def __contains__(self, key):
        return _py_interop_metrics.cycle_metric_map___contains__(self, key)

    def key_iterator(self):
        return _py_interop_metrics.cycle_metric_map_key_iterator(self)

    def value_iterator(self):
        return _py_interop_metrics.cycle_metric_map_value_iterator(self)

    def __setitem__(self, *args):
        return _py_interop_metrics.cycle_metric_map___setitem__(self, *args)

    def asdict(self):
        return _py_interop_metrics.cycle_metric_map_asdict(self)

    def __init__(self, *args):
        this = _py_interop_metrics.new_cycle_metric_map(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def empty(self):
        return _py_interop_metrics.cycle_metric_map_empty(self)

    def size(self):
        return _py_interop_metrics.cycle_metric_map_size(self)

    def swap(self, v):
        return _py_interop_metrics.cycle_metric_map_swap(self, v)

    def rbegin(self):
        return _py_interop_metrics.cycle_metric_map_rbegin(self)

    def rend(self):
        return _py_interop_metrics.cycle_metric_map_rend(self)

    def clear(self):
        return _py_interop_metrics.cycle_metric_map_clear(self)

    def get_allocator(self):
        return _py_interop_metrics.cycle_metric_map_get_allocator(self)

    def count(self, x):
        return _py_interop_metrics.cycle_metric_map_count(self, x)

    def erase(self, *args):
        return _py_interop_metrics.cycle_metric_map_erase(self, *args)

    def find(self, x):
        return _py_interop_metrics.cycle_metric_map_find(self, x)

    def lower_bound(self, x):
        return _py_interop_metrics.cycle_metric_map_lower_bound(self, x)

    def upper_bound(self, x):
        return _py_interop_metrics.cycle_metric_map_upper_bound(self, x)
    __swig_destroy__ = _py_interop_metrics.delete_cycle_metric_map
    __del__ = lambda self: None
cycle_metric_map_swigregister = _py_interop_metrics.cycle_metric_map_swigregister
cycle_metric_map_swigregister(cycle_metric_map)

class read_metric_vector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, read_metric_vector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, read_metric_vector, name)
    __repr__ = _swig_repr
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _py_interop_metrics.read_metric_vector___nonzero__(self)

    def __bool__(self):
        return _py_interop_metrics.read_metric_vector___bool__(self)

    def __len__(self):
        return _py_interop_metrics.read_metric_vector___len__(self)

    def __getslice__(self, i, j):
        return _py_interop_metrics.read_metric_vector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _py_interop_metrics.read_metric_vector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _py_interop_metrics.read_metric_vector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _py_interop_metrics.read_metric_vector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _py_interop_metrics.read_metric_vector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _py_interop_metrics.read_metric_vector___setitem__(self, *args)

    def pop(self):
        return _py_interop_metrics.read_metric_vector_pop(self)

    def append(self, x):
        return _py_interop_metrics.read_metric_vector_append(self, x)

    def empty(self):
        return _py_interop_metrics.read_metric_vector_empty(self)

    def size(self):
        return _py_interop_metrics.read_metric_vector_size(self)

    def swap(self, v):
        return _py_interop_metrics.read_metric_vector_swap(self, v)

    def rbegin(self):
        return _py_interop_metrics.read_metric_vector_rbegin(self)

    def rend(self):
        return _py_interop_metrics.read_metric_vector_rend(self)

    def clear(self):
        return _py_interop_metrics.read_metric_vector_clear(self)

    def get_allocator(self):
        return _py_interop_metrics.read_metric_vector_get_allocator(self)

    def pop_back(self):
        return _py_interop_metrics.read_metric_vector_pop_back(self)

    def erase(self, *args):
        return _py_interop_metrics.read_metric_vector_erase(self, *args)

    def __init__(self, *args):
        this = _py_interop_metrics.new_read_metric_vector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _py_interop_metrics.read_metric_vector_push_back(self, x)

    def front(self):
        return _py_interop_metrics.read_metric_vector_front(self)

    def back(self):
        return _py_interop_metrics.read_metric_vector_back(self)

    def assign(self, n, x):
        return _py_interop_metrics.read_metric_vector_assign(self, n, x)

    def resize(self, *args):
        return _py_interop_metrics.read_metric_vector_resize(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.read_metric_vector_insert(self, *args)

    def reserve(self, n):
        return _py_interop_metrics.read_metric_vector_reserve(self, n)

    def capacity(self):
        return _py_interop_metrics.read_metric_vector_capacity(self)
    __swig_destroy__ = _py_interop_metrics.delete_read_metric_vector
    __del__ = lambda self: None
read_metric_vector_swigregister = _py_interop_metrics.read_metric_vector_swigregister
read_metric_vector_swigregister(read_metric_vector)

class q_score_bin_vector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, q_score_bin_vector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, q_score_bin_vector, name)
    __repr__ = _swig_repr
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _py_interop_metrics.q_score_bin_vector___nonzero__(self)

    def __bool__(self):
        return _py_interop_metrics.q_score_bin_vector___bool__(self)

    def __len__(self):
        return _py_interop_metrics.q_score_bin_vector___len__(self)

    def __getslice__(self, i, j):
        return _py_interop_metrics.q_score_bin_vector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _py_interop_metrics.q_score_bin_vector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _py_interop_metrics.q_score_bin_vector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _py_interop_metrics.q_score_bin_vector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _py_interop_metrics.q_score_bin_vector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _py_interop_metrics.q_score_bin_vector___setitem__(self, *args)

    def pop(self):
        return _py_interop_metrics.q_score_bin_vector_pop(self)

    def append(self, x):
        return _py_interop_metrics.q_score_bin_vector_append(self, x)

    def empty(self):
        return _py_interop_metrics.q_score_bin_vector_empty(self)

    def size(self):
        return _py_interop_metrics.q_score_bin_vector_size(self)

    def swap(self, v):
        return _py_interop_metrics.q_score_bin_vector_swap(self, v)

    def rbegin(self):
        return _py_interop_metrics.q_score_bin_vector_rbegin(self)

    def rend(self):
        return _py_interop_metrics.q_score_bin_vector_rend(self)

    def clear(self):
        return _py_interop_metrics.q_score_bin_vector_clear(self)

    def get_allocator(self):
        return _py_interop_metrics.q_score_bin_vector_get_allocator(self)

    def pop_back(self):
        return _py_interop_metrics.q_score_bin_vector_pop_back(self)

    def erase(self, *args):
        return _py_interop_metrics.q_score_bin_vector_erase(self, *args)

    def __init__(self, *args):
        this = _py_interop_metrics.new_q_score_bin_vector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _py_interop_metrics.q_score_bin_vector_push_back(self, x)

    def front(self):
        return _py_interop_metrics.q_score_bin_vector_front(self)

    def back(self):
        return _py_interop_metrics.q_score_bin_vector_back(self)

    def assign(self, n, x):
        return _py_interop_metrics.q_score_bin_vector_assign(self, n, x)

    def resize(self, *args):
        return _py_interop_metrics.q_score_bin_vector_resize(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.q_score_bin_vector_insert(self, *args)

    def reserve(self, n):
        return _py_interop_metrics.q_score_bin_vector_reserve(self, n)

    def capacity(self):
        return _py_interop_metrics.q_score_bin_vector_capacity(self)
    __swig_destroy__ = _py_interop_metrics.delete_q_score_bin_vector
    __del__ = lambda self: None
q_score_bin_vector_swigregister = _py_interop_metrics.q_score_bin_vector_swigregister
q_score_bin_vector_swigregister(q_score_bin_vector)

class metric_type_name_pair(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, metric_type_name_pair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, metric_type_name_pair, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _py_interop_metrics.new_metric_type_name_pair(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_setmethods__["first"] = _py_interop_metrics.metric_type_name_pair_first_set
    __swig_getmethods__["first"] = _py_interop_metrics.metric_type_name_pair_first_get
    if _newclass:
        first = _swig_property(_py_interop_metrics.metric_type_name_pair_first_get, _py_interop_metrics.metric_type_name_pair_first_set)
    __swig_setmethods__["second"] = _py_interop_metrics.metric_type_name_pair_second_set
    __swig_getmethods__["second"] = _py_interop_metrics.metric_type_name_pair_second_get
    if _newclass:
        second = _swig_property(_py_interop_metrics.metric_type_name_pair_second_get, _py_interop_metrics.metric_type_name_pair_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _py_interop_metrics.delete_metric_type_name_pair
    __del__ = lambda self: None
metric_type_name_pair_swigregister = _py_interop_metrics.metric_type_name_pair_swigregister
metric_type_name_pair_swigregister(metric_type_name_pair)

class metric_type_description(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, metric_type_description, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, metric_type_description, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _py_interop_metrics.new_metric_type_description(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def value(self):
        return _py_interop_metrics.metric_type_description_value(self)

    def description(self):
        return _py_interop_metrics.metric_type_description_description(self)
    __swig_destroy__ = _py_interop_metrics.delete_metric_type_description
    __del__ = lambda self: None
metric_type_description_swigregister = _py_interop_metrics.metric_type_description_swigregister
metric_type_description_swigregister(metric_type_description)

class metric_type_description_vector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, metric_type_description_vector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, metric_type_description_vector, name)
    __repr__ = _swig_repr
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _py_interop_metrics.metric_type_description_vector___nonzero__(self)

    def __bool__(self):
        return _py_interop_metrics.metric_type_description_vector___bool__(self)

    def __len__(self):
        return _py_interop_metrics.metric_type_description_vector___len__(self)

    def __getslice__(self, i, j):
        return _py_interop_metrics.metric_type_description_vector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _py_interop_metrics.metric_type_description_vector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _py_interop_metrics.metric_type_description_vector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _py_interop_metrics.metric_type_description_vector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _py_interop_metrics.metric_type_description_vector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _py_interop_metrics.metric_type_description_vector___setitem__(self, *args)

    def pop(self):
        return _py_interop_metrics.metric_type_description_vector_pop(self)

    def append(self, x):
        return _py_interop_metrics.metric_type_description_vector_append(self, x)

    def empty(self):
        return _py_interop_metrics.metric_type_description_vector_empty(self)

    def size(self):
        return _py_interop_metrics.metric_type_description_vector_size(self)

    def swap(self, v):
        return _py_interop_metrics.metric_type_description_vector_swap(self, v)

    def rbegin(self):
        return _py_interop_metrics.metric_type_description_vector_rbegin(self)

    def rend(self):
        return _py_interop_metrics.metric_type_description_vector_rend(self)

    def clear(self):
        return _py_interop_metrics.metric_type_description_vector_clear(self)

    def get_allocator(self):
        return _py_interop_metrics.metric_type_description_vector_get_allocator(self)

    def pop_back(self):
        return _py_interop_metrics.metric_type_description_vector_pop_back(self)

    def erase(self, *args):
        return _py_interop_metrics.metric_type_description_vector_erase(self, *args)

    def __init__(self, *args):
        this = _py_interop_metrics.new_metric_type_description_vector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _py_interop_metrics.metric_type_description_vector_push_back(self, x)

    def front(self):
        return _py_interop_metrics.metric_type_description_vector_front(self)

    def back(self):
        return _py_interop_metrics.metric_type_description_vector_back(self)

    def assign(self, n, x):
        return _py_interop_metrics.metric_type_description_vector_assign(self, n, x)

    def resize(self, *args):
        return _py_interop_metrics.metric_type_description_vector_resize(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.metric_type_description_vector_insert(self, *args)

    def reserve(self, n):
        return _py_interop_metrics.metric_type_description_vector_reserve(self, n)

    def capacity(self):
        return _py_interop_metrics.metric_type_description_vector_capacity(self)
    __swig_destroy__ = _py_interop_metrics.delete_metric_type_description_vector
    __del__ = lambda self: None
metric_type_description_vector_swigregister = _py_interop_metrics.metric_type_description_vector_swigregister
metric_type_description_vector_swigregister(metric_type_description_vector)

class metric_type_vector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, metric_type_vector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, metric_type_vector, name)
    __repr__ = _swig_repr
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _py_interop_metrics.metric_type_vector___nonzero__(self)

    def __bool__(self):
        return _py_interop_metrics.metric_type_vector___bool__(self)

    def __len__(self):
        return _py_interop_metrics.metric_type_vector___len__(self)

    def __getslice__(self, i, j):
        return _py_interop_metrics.metric_type_vector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _py_interop_metrics.metric_type_vector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _py_interop_metrics.metric_type_vector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _py_interop_metrics.metric_type_vector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _py_interop_metrics.metric_type_vector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _py_interop_metrics.metric_type_vector___setitem__(self, *args)

    def pop(self):
        return _py_interop_metrics.metric_type_vector_pop(self)

    def append(self, x):
        return _py_interop_metrics.metric_type_vector_append(self, x)

    def empty(self):
        return _py_interop_metrics.metric_type_vector_empty(self)

    def size(self):
        return _py_interop_metrics.metric_type_vector_size(self)

    def swap(self, v):
        return _py_interop_metrics.metric_type_vector_swap(self, v)

    def rbegin(self):
        return _py_interop_metrics.metric_type_vector_rbegin(self)

    def rend(self):
        return _py_interop_metrics.metric_type_vector_rend(self)

    def clear(self):
        return _py_interop_metrics.metric_type_vector_clear(self)

    def get_allocator(self):
        return _py_interop_metrics.metric_type_vector_get_allocator(self)

    def pop_back(self):
        return _py_interop_metrics.metric_type_vector_pop_back(self)

    def erase(self, *args):
        return _py_interop_metrics.metric_type_vector_erase(self, *args)

    def __init__(self, *args):
        this = _py_interop_metrics.new_metric_type_vector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _py_interop_metrics.metric_type_vector_push_back(self, x)

    def front(self):
        return _py_interop_metrics.metric_type_vector_front(self)

    def back(self):
        return _py_interop_metrics.metric_type_vector_back(self)

    def assign(self, n, x):
        return _py_interop_metrics.metric_type_vector_assign(self, n, x)

    def resize(self, *args):
        return _py_interop_metrics.metric_type_vector_resize(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.metric_type_vector_insert(self, *args)

    def reserve(self, n):
        return _py_interop_metrics.metric_type_vector_reserve(self, n)

    def capacity(self):
        return _py_interop_metrics.metric_type_vector_capacity(self)
    __swig_destroy__ = _py_interop_metrics.delete_metric_type_vector
    __del__ = lambda self: None
metric_type_vector_swigregister = _py_interop_metrics.metric_type_vector_swigregister
metric_type_vector_swigregister(metric_type_vector)

class metric_group_vector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, metric_group_vector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, metric_group_vector, name)
    __repr__ = _swig_repr
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _py_interop_metrics.metric_group_vector___nonzero__(self)

    def __bool__(self):
        return _py_interop_metrics.metric_group_vector___bool__(self)

    def __len__(self):
        return _py_interop_metrics.metric_group_vector___len__(self)

    def __getslice__(self, i, j):
        return _py_interop_metrics.metric_group_vector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _py_interop_metrics.metric_group_vector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _py_interop_metrics.metric_group_vector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _py_interop_metrics.metric_group_vector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _py_interop_metrics.metric_group_vector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _py_interop_metrics.metric_group_vector___setitem__(self, *args)

    def pop(self):
        return _py_interop_metrics.metric_group_vector_pop(self)

    def append(self, x):
        return _py_interop_metrics.metric_group_vector_append(self, x)

    def empty(self):
        return _py_interop_metrics.metric_group_vector_empty(self)

    def size(self):
        return _py_interop_metrics.metric_group_vector_size(self)

    def swap(self, v):
        return _py_interop_metrics.metric_group_vector_swap(self, v)

    def rbegin(self):
        return _py_interop_metrics.metric_group_vector_rbegin(self)

    def rend(self):
        return _py_interop_metrics.metric_group_vector_rend(self)

    def clear(self):
        return _py_interop_metrics.metric_group_vector_clear(self)

    def get_allocator(self):
        return _py_interop_metrics.metric_group_vector_get_allocator(self)

    def pop_back(self):
        return _py_interop_metrics.metric_group_vector_pop_back(self)

    def erase(self, *args):
        return _py_interop_metrics.metric_group_vector_erase(self, *args)

    def __init__(self, *args):
        this = _py_interop_metrics.new_metric_group_vector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _py_interop_metrics.metric_group_vector_push_back(self, x)

    def front(self):
        return _py_interop_metrics.metric_group_vector_front(self)

    def back(self):
        return _py_interop_metrics.metric_group_vector_back(self)

    def assign(self, n, x):
        return _py_interop_metrics.metric_group_vector_assign(self, n, x)

    def resize(self, *args):
        return _py_interop_metrics.metric_group_vector_resize(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.metric_group_vector_insert(self, *args)

    def reserve(self, n):
        return _py_interop_metrics.metric_group_vector_reserve(self, n)

    def capacity(self):
        return _py_interop_metrics.metric_group_vector_capacity(self)
    __swig_destroy__ = _py_interop_metrics.delete_metric_group_vector
    __del__ = lambda self: None
metric_group_vector_swigregister = _py_interop_metrics.metric_group_vector_swigregister
metric_group_vector_swigregister(metric_group_vector)

class corrected_intensity_metric(base_cycle_metric):
    __swig_setmethods__ = {}
    for _s in [base_cycle_metric]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, corrected_intensity_metric, name, value)
    __swig_getmethods__ = {}
    for _s in [base_cycle_metric]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, corrected_intensity_metric, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.corrected_intensity_metric_TYPE
    LATEST_VERSION = _py_interop_metrics.corrected_intensity_metric_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_corrected_intensity_metric(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def set(self, lane, tile, cycle, called_counts):
        return _py_interop_metrics.corrected_intensity_metric_set(self, lane, tile, cycle, called_counts)

    def average_cycle_intensity(self):
        return _py_interop_metrics.corrected_intensity_metric_average_cycle_intensity(self)

    def corrected_int_all(self, index):
        return _py_interop_metrics.corrected_intensity_metric_corrected_int_all(self, index)

    def corrected_int_all_float(self, index):
        return _py_interop_metrics.corrected_intensity_metric_corrected_int_all_float(self, index)

    def corrected_int_called(self, index):
        return _py_interop_metrics.corrected_intensity_metric_corrected_int_called(self, index)

    def called_counts_array(self):
        return _py_interop_metrics.corrected_intensity_metric_called_counts_array(self)

    def corrected_int_all_array(self):
        return _py_interop_metrics.corrected_intensity_metric_corrected_int_all_array(self)

    def called_counts(self, index):
        return _py_interop_metrics.corrected_intensity_metric_called_counts(self, index)

    def no_calls(self):
        return _py_interop_metrics.corrected_intensity_metric_no_calls(self)

    def signal_to_noise(self):
        return _py_interop_metrics.corrected_intensity_metric_signal_to_noise(self)

    def total_calls(self, nocalls=False):
        return _py_interop_metrics.corrected_intensity_metric_total_calls(self, nocalls)

    def total_intensity(self):
        return _py_interop_metrics.corrected_intensity_metric_total_intensity(self)

    def total_called_intensity(self):
        return _py_interop_metrics.corrected_intensity_metric_total_called_intensity(self)

    def percent_base(self, index):
        return _py_interop_metrics.corrected_intensity_metric_percent_base(self, index)

    def percent_bases(self):
        return _py_interop_metrics.corrected_intensity_metric_percent_bases(self)

    def percent_nocall(self):
        return _py_interop_metrics.corrected_intensity_metric_percent_nocall(self)

    def corrected_int_called_array(self, *args):
        return _py_interop_metrics.corrected_intensity_metric_corrected_int_called_array(self, *args)

    def any_valid_called_int(self):
        return _py_interop_metrics.corrected_intensity_metric_any_valid_called_int(self)

    def averageCycleIntensity(self):
        return _py_interop_metrics.corrected_intensity_metric_averageCycleIntensity(self)

    def correctedIntCalled(self, *args):
        return _py_interop_metrics.corrected_intensity_metric_correctedIntCalled(self, *args)

    def correctedIntAll(self, *args):
        return _py_interop_metrics.corrected_intensity_metric_correctedIntAll(self, *args)

    def noCalls(self):
        return _py_interop_metrics.corrected_intensity_metric_noCalls(self)

    def percentBase(self, index):
        return _py_interop_metrics.corrected_intensity_metric_percentBase(self, index)

    def calledCounts(self, *args):
        return _py_interop_metrics.corrected_intensity_metric_calledCounts(self, *args)

    def signalToNoise(self):
        return _py_interop_metrics.corrected_intensity_metric_signalToNoise(self)

    def totalCalls(self, nocalls=False):
        return _py_interop_metrics.corrected_intensity_metric_totalCalls(self, nocalls)

    def totalIntensity(self):
        return _py_interop_metrics.corrected_intensity_metric_totalIntensity(self)

    def totalCalledIntensity(self):
        return _py_interop_metrics.corrected_intensity_metric_totalCalledIntensity(self)

    def percentIntensity(self, index):
        return _py_interop_metrics.corrected_intensity_metric_percentIntensity(self, index)

    def percentCalledIntensity(self, index):
        return _py_interop_metrics.corrected_intensity_metric_percentCalledIntensity(self, index)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.corrected_intensity_metric_prefix)
    else:
        prefix = _py_interop_metrics.corrected_intensity_metric_prefix
    __swig_destroy__ = _py_interop_metrics.delete_corrected_intensity_metric
    __del__ = lambda self: None
corrected_intensity_metric_swigregister = _py_interop_metrics.corrected_intensity_metric_swigregister
corrected_intensity_metric_swigregister(corrected_intensity_metric)

def corrected_intensity_metric_prefix():
    return _py_interop_metrics.corrected_intensity_metric_prefix()
corrected_intensity_metric_prefix = _py_interop_metrics.corrected_intensity_metric_prefix

class error_metric(base_cycle_metric):
    __swig_setmethods__ = {}
    for _s in [base_cycle_metric]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, error_metric, name, value)
    __swig_getmethods__ = {}
    for _s in [base_cycle_metric]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, error_metric, name)
    __repr__ = _swig_repr
    MAX_MISMATCH = _py_interop_metrics.error_metric_MAX_MISMATCH
    TYPE = _py_interop_metrics.error_metric_TYPE
    LATEST_VERSION = _py_interop_metrics.error_metric_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_error_metric(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def error_rate(self):
        return _py_interop_metrics.error_metric_error_rate(self)

    def mismatch_cluster_count(self, n):
        return _py_interop_metrics.error_metric_mismatch_cluster_count(self, n)

    def mismatch_count(self):
        return _py_interop_metrics.error_metric_mismatch_count(self)

    def mismatch_cluster_counts(self):
        return _py_interop_metrics.error_metric_mismatch_cluster_counts(self)

    def errorRate(self):
        return _py_interop_metrics.error_metric_errorRate(self)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.error_metric_prefix)
    else:
        prefix = _py_interop_metrics.error_metric_prefix
    __swig_destroy__ = _py_interop_metrics.delete_error_metric
    __del__ = lambda self: None
error_metric_swigregister = _py_interop_metrics.error_metric_swigregister
error_metric_swigregister(error_metric)

def error_metric_prefix():
    return _py_interop_metrics.error_metric_prefix()
error_metric_prefix = _py_interop_metrics.error_metric_prefix

class extraction_metric_header(base_cycle_metric_header):
    __swig_setmethods__ = {}
    for _s in [base_cycle_metric_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, extraction_metric_header, name, value)
    __swig_getmethods__ = {}
    for _s in [base_cycle_metric_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, extraction_metric_header, name)
    __repr__ = _swig_repr
    MAX_CHANNELS = _py_interop_metrics.extraction_metric_header_MAX_CHANNELS

    def __init__(self, channel_count):
        this = _py_interop_metrics.new_extraction_metric_header(channel_count)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def channel_count(self, *args):
        return _py_interop_metrics.extraction_metric_header_channel_count(self, *args)
    if _newclass:
        default_header = staticmethod(_py_interop_metrics.extraction_metric_header_default_header)
    else:
        default_header = _py_interop_metrics.extraction_metric_header_default_header

    def clear(self):
        return _py_interop_metrics.extraction_metric_header_clear(self)
    __swig_destroy__ = _py_interop_metrics.delete_extraction_metric_header
    __del__ = lambda self: None
extraction_metric_header_swigregister = _py_interop_metrics.extraction_metric_header_swigregister
extraction_metric_header_swigregister(extraction_metric_header)

def extraction_metric_header_default_header():
    return _py_interop_metrics.extraction_metric_header_default_header()
extraction_metric_header_default_header = _py_interop_metrics.extraction_metric_header_default_header

class extraction_metric(base_cycle_metric):
    __swig_setmethods__ = {}
    for _s in [base_cycle_metric]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, extraction_metric, name, value)
    __swig_getmethods__ = {}
    for _s in [base_cycle_metric]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, extraction_metric, name)
    __repr__ = _swig_repr
    MAX_CHANNELS = _py_interop_metrics.extraction_metric_MAX_CHANNELS
    TYPE = _py_interop_metrics.extraction_metric_TYPE
    LATEST_VERSION = _py_interop_metrics.extraction_metric_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_extraction_metric(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def set(self, *args):
        return _py_interop_metrics.extraction_metric_set(self, *args)

    def date_time_csharp(self):
        return _py_interop_metrics.extraction_metric_date_time_csharp(self)

    def date_time_csharp_raw(self):
        return _py_interop_metrics.extraction_metric_date_time_csharp_raw(self)

    def max_intensity(self, channel):
        return _py_interop_metrics.extraction_metric_max_intensity(self, channel)

    def focus_score(self, channel):
        return _py_interop_metrics.extraction_metric_focus_score(self, channel)

    def max_intensity_values(self):
        return _py_interop_metrics.extraction_metric_max_intensity_values(self)

    def focus_scores(self):
        return _py_interop_metrics.extraction_metric_focus_scores(self)

    def channel_count(self):
        return _py_interop_metrics.extraction_metric_channel_count(self)

    def trim(self, channel_count):
        return _py_interop_metrics.extraction_metric_trim(self, channel_count)

    def focusScore(self, channel):
        return _py_interop_metrics.extraction_metric_focusScore(self, channel)

    def dateTime(self):
        return _py_interop_metrics.extraction_metric_dateTime(self)

    def focusScores(self):
        return _py_interop_metrics.extraction_metric_focusScores(self)

    def date_time(self, *args):
        return _py_interop_metrics.extraction_metric_date_time(self, *args)

    def is_any_p90_zero(self):
        return _py_interop_metrics.extraction_metric_is_any_p90_zero(self)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.extraction_metric_prefix)
    else:
        prefix = _py_interop_metrics.extraction_metric_prefix
    __swig_destroy__ = _py_interop_metrics.delete_extraction_metric
    __del__ = lambda self: None
extraction_metric_swigregister = _py_interop_metrics.extraction_metric_swigregister
extraction_metric_swigregister(extraction_metric)

def extraction_metric_prefix():
    return _py_interop_metrics.extraction_metric_prefix()
extraction_metric_prefix = _py_interop_metrics.extraction_metric_prefix

class image_metric_header(base_cycle_metric_header):
    __swig_setmethods__ = {}
    for _s in [base_cycle_metric_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, image_metric_header, name, value)
    __swig_getmethods__ = {}
    for _s in [base_cycle_metric_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, image_metric_header, name)
    __repr__ = _swig_repr
    MAX_CHANNELS = _py_interop_metrics.image_metric_header_MAX_CHANNELS

    def __init__(self, channel_count):
        this = _py_interop_metrics.new_image_metric_header(channel_count)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def channelCount(self):
        return _py_interop_metrics.image_metric_header_channelCount(self)

    def channel_count(self, *args):
        return _py_interop_metrics.image_metric_header_channel_count(self, *args)
    if _newclass:
        default_header = staticmethod(_py_interop_metrics.image_metric_header_default_header)
    else:
        default_header = _py_interop_metrics.image_metric_header_default_header

    def clear(self):
        return _py_interop_metrics.image_metric_header_clear(self)
    __swig_destroy__ = _py_interop_metrics.delete_image_metric_header
    __del__ = lambda self: None
image_metric_header_swigregister = _py_interop_metrics.image_metric_header_swigregister
image_metric_header_swigregister(image_metric_header)

def image_metric_header_default_header():
    return _py_interop_metrics.image_metric_header_default_header()
image_metric_header_default_header = _py_interop_metrics.image_metric_header_default_header

class image_metric(base_cycle_metric):
    __swig_setmethods__ = {}
    for _s in [base_cycle_metric]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, image_metric, name, value)
    __swig_getmethods__ = {}
    for _s in [base_cycle_metric]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, image_metric, name)
    __repr__ = _swig_repr
    MAX_CHANNELS = _py_interop_metrics.image_metric_MAX_CHANNELS
    TYPE = _py_interop_metrics.image_metric_TYPE
    LATEST_VERSION = _py_interop_metrics.image_metric_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_image_metric(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def min_contrast(self, channel):
        return _py_interop_metrics.image_metric_min_contrast(self, channel)

    def max_contrast(self, channel):
        return _py_interop_metrics.image_metric_max_contrast(self, channel)

    def min_contrast_array(self):
        return _py_interop_metrics.image_metric_min_contrast_array(self)

    def max_contrast_array(self):
        return _py_interop_metrics.image_metric_max_contrast_array(self)

    def channel_count(self):
        return _py_interop_metrics.image_metric_channel_count(self)

    def is_any_channel_blank(self):
        return _py_interop_metrics.image_metric_is_any_channel_blank(self)

    def trim(self, channel_count):
        return _py_interop_metrics.image_metric_trim(self, channel_count)

    def minContrast(self, *args):
        return _py_interop_metrics.image_metric_minContrast(self, *args)

    def maxContrast(self, *args):
        return _py_interop_metrics.image_metric_maxContrast(self, *args)

    def channelCount(self):
        return _py_interop_metrics.image_metric_channelCount(self)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.image_metric_prefix)
    else:
        prefix = _py_interop_metrics.image_metric_prefix
    __swig_destroy__ = _py_interop_metrics.delete_image_metric
    __del__ = lambda self: None
image_metric_swigregister = _py_interop_metrics.image_metric_swigregister
image_metric_swigregister(image_metric)

def image_metric_prefix():
    return _py_interop_metrics.image_metric_prefix()
image_metric_prefix = _py_interop_metrics.image_metric_prefix

class q_score_bin(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, q_score_bin, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, q_score_bin, name)
    __repr__ = _swig_repr

    def __init__(self, lower=0, upper=0, value=0):
        this = _py_interop_metrics.new_q_score_bin(lower, upper, value)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def lower(self):
        return _py_interop_metrics.q_score_bin_lower(self)

    def upper(self):
        return _py_interop_metrics.q_score_bin_upper(self)

    def value(self):
        return _py_interop_metrics.q_score_bin_value(self)
    __swig_destroy__ = _py_interop_metrics.delete_q_score_bin
    __del__ = lambda self: None
q_score_bin_swigregister = _py_interop_metrics.q_score_bin_swigregister
q_score_bin_swigregister(q_score_bin)

class q_score_header(base_cycle_metric_header):
    __swig_setmethods__ = {}
    for _s in [base_cycle_metric_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, q_score_header, name, value)
    __swig_getmethods__ = {}
    for _s in [base_cycle_metric_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, q_score_header, name)
    __repr__ = _swig_repr
    MAX_Q_BINS = _py_interop_metrics.q_score_header_MAX_Q_BINS

    def __init__(self, *args):
        this = _py_interop_metrics.new_q_score_header(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def bin_at(self, n):
        return _py_interop_metrics.q_score_header_bin_at(self, n)

    def get_bins(self):
        return _py_interop_metrics.q_score_header_get_bins(self)

    def bins(self):
        return _py_interop_metrics.q_score_header_bins(self)

    def bin_count(self):
        return _py_interop_metrics.q_score_header_bin_count(self)

    def q_val_count(self):
        return _py_interop_metrics.q_score_header_q_val_count(self)

    def index_for_q_value(self, qval):
        return _py_interop_metrics.q_score_header_index_for_q_value(self, qval)

    def binCount(self):
        return _py_interop_metrics.q_score_header_binCount(self)
    if _newclass:
        default_header = staticmethod(_py_interop_metrics.q_score_header_default_header)
    else:
        default_header = _py_interop_metrics.q_score_header_default_header

    def binAt(self, n):
        return _py_interop_metrics.q_score_header_binAt(self, n)

    def clear(self):
        return _py_interop_metrics.q_score_header_clear(self)
    __swig_destroy__ = _py_interop_metrics.delete_q_score_header
    __del__ = lambda self: None
q_score_header_swigregister = _py_interop_metrics.q_score_header_swigregister
q_score_header_swigregister(q_score_header)

def q_score_header_default_header():
    return _py_interop_metrics.q_score_header_default_header()
q_score_header_default_header = _py_interop_metrics.q_score_header_default_header

class q_metric(base_cycle_metric):
    __swig_setmethods__ = {}
    for _s in [base_cycle_metric]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, q_metric, name, value)
    __swig_getmethods__ = {}
    for _s in [base_cycle_metric]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, q_metric, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.q_metric_TYPE
    LATEST_VERSION = _py_interop_metrics.q_metric_LATEST_VERSION
    MAX_Q_BINS = _py_interop_metrics.q_metric_MAX_Q_BINS

    def __init__(self, *args):
        this = _py_interop_metrics.new_q_metric(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def set(self, lane, tile, cycle, qscore_hist):
        return _py_interop_metrics.q_metric_set(self, lane, tile, cycle, qscore_hist)

    def qscore_hist(self, *args):
        return _py_interop_metrics.q_metric_qscore_hist(self, *args)

    def size(self):
        return _py_interop_metrics.q_metric_size(self)

    def sum_qscore(self):
        return _py_interop_metrics.q_metric_sum_qscore(self)

    def sum_qscore_cumulative(self):
        return _py_interop_metrics.q_metric_sum_qscore_cumulative(self)

    def total_over_qscore(self, *args):
        return _py_interop_metrics.q_metric_total_over_qscore(self, *args)

    def total_over_qscore_cumulative(self, *args):
        return _py_interop_metrics.q_metric_total_over_qscore_cumulative(self, *args)

    def percent_over_qscore(self, *args):
        return _py_interop_metrics.q_metric_percent_over_qscore(self, *args)

    def percent_over_qscore_cumulative(self, *args):
        return _py_interop_metrics.q_metric_percent_over_qscore_cumulative(self, *args)

    def median(self, *args):
        return _py_interop_metrics.q_metric_median(self, *args)

    def is_cumulative_empty(self):
        return _py_interop_metrics.q_metric_is_cumulative_empty(self)

    def accumulate(self, metric):
        return _py_interop_metrics.q_metric_accumulate(self, metric)

    def compress(self, header):
        return _py_interop_metrics.q_metric_compress(self, header)

    def qscoreHist(self, *args):
        return _py_interop_metrics.q_metric_qscoreHist(self, *args)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.q_metric_prefix)
    else:
        prefix = _py_interop_metrics.q_metric_prefix
    __swig_destroy__ = _py_interop_metrics.delete_q_metric
    __del__ = lambda self: None
q_metric_swigregister = _py_interop_metrics.q_metric_swigregister
q_metric_swigregister(q_metric)

def q_metric_prefix():
    return _py_interop_metrics.q_metric_prefix()
q_metric_prefix = _py_interop_metrics.q_metric_prefix

class tile_metric_header(base_metric_header):
    __swig_setmethods__ = {}
    for _s in [base_metric_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, tile_metric_header, name, value)
    __swig_getmethods__ = {}
    for _s in [base_metric_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, tile_metric_header, name)
    __repr__ = _swig_repr

    def __init__(self, density):
        this = _py_interop_metrics.new_tile_metric_header(density)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def density(self):
        return _py_interop_metrics.tile_metric_header_density(self)
    if _newclass:
        default_header = staticmethod(_py_interop_metrics.tile_metric_header_default_header)
    else:
        default_header = _py_interop_metrics.tile_metric_header_default_header

    def clear(self):
        return _py_interop_metrics.tile_metric_header_clear(self)
    __swig_destroy__ = _py_interop_metrics.delete_tile_metric_header
    __del__ = lambda self: None
tile_metric_header_swigregister = _py_interop_metrics.tile_metric_header_swigregister
tile_metric_header_swigregister(tile_metric_header)

def tile_metric_header_default_header():
    return _py_interop_metrics.tile_metric_header_default_header()
tile_metric_header_default_header = _py_interop_metrics.tile_metric_header_default_header

class read_metric(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, read_metric, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, read_metric, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _py_interop_metrics.new_read_metric(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def read(self):
        return _py_interop_metrics.read_metric_read(self)

    def percent_aligned(self, *args):
        return _py_interop_metrics.read_metric_percent_aligned(self, *args)

    def percent_phasing(self, *args):
        return _py_interop_metrics.read_metric_percent_phasing(self, *args)

    def percent_prephasing(self, *args):
        return _py_interop_metrics.read_metric_percent_prephasing(self, *args)
    __swig_destroy__ = _py_interop_metrics.delete_read_metric
    __del__ = lambda self: None
read_metric_swigregister = _py_interop_metrics.read_metric_swigregister
read_metric_swigregister(read_metric)

class tile_metric(base_metric):
    __swig_setmethods__ = {}
    for _s in [base_metric]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, tile_metric, name, value)
    __swig_getmethods__ = {}
    for _s in [base_metric]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, tile_metric, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.tile_metric_TYPE
    LATEST_VERSION = _py_interop_metrics.tile_metric_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_tile_metric(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def cluster_density(self):
        return _py_interop_metrics.tile_metric_cluster_density(self)

    def cluster_density_k(self):
        return _py_interop_metrics.tile_metric_cluster_density_k(self)

    def cluster_density_pf(self):
        return _py_interop_metrics.tile_metric_cluster_density_pf(self)

    def cluster_density_pf_k(self):
        return _py_interop_metrics.tile_metric_cluster_density_pf_k(self)

    def cluster_count(self):
        return _py_interop_metrics.tile_metric_cluster_count(self)

    def cluster_count_k(self):
        return _py_interop_metrics.tile_metric_cluster_count_k(self)

    def cluster_count_m(self):
        return _py_interop_metrics.tile_metric_cluster_count_m(self)

    def cluster_count_pf(self):
        return _py_interop_metrics.tile_metric_cluster_count_pf(self)

    def cluster_count_pf_k(self):
        return _py_interop_metrics.tile_metric_cluster_count_pf_k(self)

    def cluster_count_pf_m(self):
        return _py_interop_metrics.tile_metric_cluster_count_pf_m(self)

    def percent_pf(self):
        return _py_interop_metrics.tile_metric_percent_pf(self)

    def read_metrics(self):
        return _py_interop_metrics.tile_metric_read_metrics(self)

    def percent_aligned(self, n):
        return _py_interop_metrics.tile_metric_percent_aligned(self, n)

    def percent_phasing(self, n):
        return _py_interop_metrics.tile_metric_percent_phasing(self, n)

    def percent_prephasing(self, n):
        return _py_interop_metrics.tile_metric_percent_prephasing(self, n)

    def percent_aligned_at(self, number):
        return _py_interop_metrics.tile_metric_percent_aligned_at(self, number)

    def percent_phasing_at(self, number):
        return _py_interop_metrics.tile_metric_percent_phasing_at(self, number)

    def percent_prephasing_at(self, number):
        return _py_interop_metrics.tile_metric_percent_prephasing_at(self, number)

    def read_count(self):
        return _py_interop_metrics.tile_metric_read_count(self)

    def is_dead_tile(self):
        return _py_interop_metrics.tile_metric_is_dead_tile(self)

    def update_phasing_if_missing(self, number, phasing, prephasing):
        return _py_interop_metrics.tile_metric_update_phasing_if_missing(self, number, phasing, prephasing)

    def clusterDensity(self):
        return _py_interop_metrics.tile_metric_clusterDensity(self)

    def clusterDensityPf(self):
        return _py_interop_metrics.tile_metric_clusterDensityPf(self)

    def clusterCount(self):
        return _py_interop_metrics.tile_metric_clusterCount(self)

    def clusterCountPf(self):
        return _py_interop_metrics.tile_metric_clusterCountPf(self)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.tile_metric_prefix)
    else:
        prefix = _py_interop_metrics.tile_metric_prefix
    __swig_destroy__ = _py_interop_metrics.delete_tile_metric
    __del__ = lambda self: None
tile_metric_swigregister = _py_interop_metrics.tile_metric_swigregister
tile_metric_swigregister(tile_metric)

def tile_metric_prefix():
    return _py_interop_metrics.tile_metric_prefix()
tile_metric_prefix = _py_interop_metrics.tile_metric_prefix

class index_info(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, index_info, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, index_info, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _py_interop_metrics.new_index_info(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def index_seq(self):
        return _py_interop_metrics.index_info_index_seq(self)

    def sample_id(self):
        return _py_interop_metrics.index_info_sample_id(self)

    def sample_proj(self):
        return _py_interop_metrics.index_info_sample_proj(self)

    def cluster_count(self):
        return _py_interop_metrics.index_info_cluster_count(self)

    def is_dual(self):
        return _py_interop_metrics.index_info_is_dual(self)

    def index1(self):
        return _py_interop_metrics.index_info_index1(self)

    def index2(self):
        return _py_interop_metrics.index_info_index2(self)

    def unique_id(self):
        return _py_interop_metrics.index_info_unique_id(self)
    __swig_destroy__ = _py_interop_metrics.delete_index_info
    __del__ = lambda self: None
index_info_swigregister = _py_interop_metrics.index_info_swigregister
index_info_swigregister(index_info)

class index_metric_header(base_read_metric_header):
    __swig_setmethods__ = {}
    for _s in [base_read_metric_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, index_metric_header, name, value)
    __swig_getmethods__ = {}
    for _s in [base_read_metric_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, index_metric_header, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _py_interop_metrics.new_index_metric_header()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def index_order(self, *args):
        return _py_interop_metrics.index_metric_header_index_order(self, *args)
    if _newclass:
        default_header = staticmethod(_py_interop_metrics.index_metric_header_default_header)
    else:
        default_header = _py_interop_metrics.index_metric_header_default_header

    def clear(self):
        return _py_interop_metrics.index_metric_header_clear(self)
    __swig_destroy__ = _py_interop_metrics.delete_index_metric_header
    __del__ = lambda self: None
index_metric_header_swigregister = _py_interop_metrics.index_metric_header_swigregister
index_metric_header_swigregister(index_metric_header)

def index_metric_header_default_header():
    return _py_interop_metrics.index_metric_header_default_header()
index_metric_header_default_header = _py_interop_metrics.index_metric_header_default_header

class index_metric(base_read_metric):
    __swig_setmethods__ = {}
    for _s in [base_read_metric]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, index_metric, name, value)
    __swig_getmethods__ = {}
    for _s in [base_read_metric]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, index_metric, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.index_metric_TYPE
    LATEST_VERSION = _py_interop_metrics.index_metric_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_index_metric(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def size(self):
        return _py_interop_metrics.index_metric_size(self)

    def indices(self, *args):
        return _py_interop_metrics.index_metric_indices(self, *args)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.index_metric_prefix)
    else:
        prefix = _py_interop_metrics.index_metric_prefix
    __swig_destroy__ = _py_interop_metrics.delete_index_metric
    __del__ = lambda self: None
index_metric_swigregister = _py_interop_metrics.index_metric_swigregister
index_metric_swigregister(index_metric)

def index_metric_prefix():
    return _py_interop_metrics.index_metric_prefix()
index_metric_prefix = _py_interop_metrics.index_metric_prefix

class q_collapsed_header(q_score_header):
    __swig_setmethods__ = {}
    for _s in [q_score_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, q_collapsed_header, name, value)
    __swig_getmethods__ = {}
    for _s in [q_score_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, q_collapsed_header, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _py_interop_metrics.new_q_collapsed_header(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    if _newclass:
        default_header = staticmethod(_py_interop_metrics.q_collapsed_header_default_header)
    else:
        default_header = _py_interop_metrics.q_collapsed_header_default_header

    def clear(self):
        return _py_interop_metrics.q_collapsed_header_clear(self)
    __swig_destroy__ = _py_interop_metrics.delete_q_collapsed_header
    __del__ = lambda self: None
q_collapsed_header_swigregister = _py_interop_metrics.q_collapsed_header_swigregister
q_collapsed_header_swigregister(q_collapsed_header)

def q_collapsed_header_default_header():
    return _py_interop_metrics.q_collapsed_header_default_header()
q_collapsed_header_default_header = _py_interop_metrics.q_collapsed_header_default_header

class q_collapsed_metric(base_cycle_metric):
    __swig_setmethods__ = {}
    for _s in [base_cycle_metric]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, q_collapsed_metric, name, value)
    __swig_getmethods__ = {}
    for _s in [base_cycle_metric]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, q_collapsed_metric, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.q_collapsed_metric_TYPE
    LATEST_VERSION = _py_interop_metrics.q_collapsed_metric_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_q_collapsed_metric(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def q20(self):
        return _py_interop_metrics.q_collapsed_metric_q20(self)

    def q30(self):
        return _py_interop_metrics.q_collapsed_metric_q30(self)

    def total(self):
        return _py_interop_metrics.q_collapsed_metric_total(self)

    def median_qscore(self):
        return _py_interop_metrics.q_collapsed_metric_median_qscore(self)

    def median_qscore_flt(self):
        return _py_interop_metrics.q_collapsed_metric_median_qscore_flt(self)

    def cumulative_q20(self):
        return _py_interop_metrics.q_collapsed_metric_cumulative_q20(self)

    def cumulative_q30(self):
        return _py_interop_metrics.q_collapsed_metric_cumulative_q30(self)

    def cumulative_total(self):
        return _py_interop_metrics.q_collapsed_metric_cumulative_total(self)

    def percent_over_q20(self):
        return _py_interop_metrics.q_collapsed_metric_percent_over_q20(self)

    def percent_over_q30(self):
        return _py_interop_metrics.q_collapsed_metric_percent_over_q30(self)

    def cumulative_percent_over_q20(self):
        return _py_interop_metrics.q_collapsed_metric_cumulative_percent_over_q20(self)

    def cumulative_percent_over_q30(self):
        return _py_interop_metrics.q_collapsed_metric_cumulative_percent_over_q30(self)

    def accumulate(self, metric):
        return _py_interop_metrics.q_collapsed_metric_accumulate(self, metric)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.q_collapsed_metric_prefix)
    else:
        prefix = _py_interop_metrics.q_collapsed_metric_prefix
    if _newclass:
        suffix = staticmethod(_py_interop_metrics.q_collapsed_metric_suffix)
    else:
        suffix = _py_interop_metrics.q_collapsed_metric_suffix
    __swig_destroy__ = _py_interop_metrics.delete_q_collapsed_metric
    __del__ = lambda self: None
q_collapsed_metric_swigregister = _py_interop_metrics.q_collapsed_metric_swigregister
q_collapsed_metric_swigregister(q_collapsed_metric)

def q_collapsed_metric_prefix():
    return _py_interop_metrics.q_collapsed_metric_prefix()
q_collapsed_metric_prefix = _py_interop_metrics.q_collapsed_metric_prefix

def q_collapsed_metric_suffix():
    return _py_interop_metrics.q_collapsed_metric_suffix()
q_collapsed_metric_suffix = _py_interop_metrics.q_collapsed_metric_suffix

class q_by_lane_metric(q_metric):
    __swig_setmethods__ = {}
    for _s in [q_metric]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, q_by_lane_metric, name, value)
    __swig_getmethods__ = {}
    for _s in [q_metric]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, q_by_lane_metric, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.q_by_lane_metric_TYPE
    LATEST_VERSION = _py_interop_metrics.q_by_lane_metric_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_q_by_lane_metric(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def accumulate_by_lane(self, metric):
        return _py_interop_metrics.q_by_lane_metric_accumulate_by_lane(self, metric)
    if _newclass:
        suffix = staticmethod(_py_interop_metrics.q_by_lane_metric_suffix)
    else:
        suffix = _py_interop_metrics.q_by_lane_metric_suffix
    __swig_destroy__ = _py_interop_metrics.delete_q_by_lane_metric
    __del__ = lambda self: None
q_by_lane_metric_swigregister = _py_interop_metrics.q_by_lane_metric_swigregister
q_by_lane_metric_swigregister(q_by_lane_metric)

def q_by_lane_metric_suffix():
    return _py_interop_metrics.q_by_lane_metric_suffix()
q_by_lane_metric_suffix = _py_interop_metrics.q_by_lane_metric_suffix

class base_corrected_intensity_metrics(base_cycle_metric_header):
    __swig_setmethods__ = {}
    for _s in [base_cycle_metric_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, base_corrected_intensity_metrics, name, value)
    __swig_getmethods__ = {}
    for _s in [base_cycle_metric_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, base_corrected_intensity_metrics, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.base_corrected_intensity_metrics_TYPE
    LATEST_VERSION = _py_interop_metrics.base_corrected_intensity_metrics_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_base_corrected_intensity_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def data_source_exists(self, *args):
        return _py_interop_metrics.base_corrected_intensity_metrics_data_source_exists(self, *args)

    def rebuild_index(self, update_ids=False):
        return _py_interop_metrics.base_corrected_intensity_metrics_rebuild_index(self, update_ids)

    def resize(self, n):
        return _py_interop_metrics.base_corrected_intensity_metrics_resize(self, n)

    def reserve(self, n):
        return _py_interop_metrics.base_corrected_intensity_metrics_reserve(self, n)

    def trim(self, n):
        return _py_interop_metrics.base_corrected_intensity_metrics_trim(self, n)

    def find(self, *args):
        return _py_interop_metrics.base_corrected_intensity_metrics_find(self, *args)

    def has_metric(self, *args):
        return _py_interop_metrics.base_corrected_intensity_metrics_has_metric(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.base_corrected_intensity_metrics_insert(self, *args)

    def get_metric(self, *args):
        return _py_interop_metrics.base_corrected_intensity_metrics_get_metric(self, *args)

    def at(self, n):
        return _py_interop_metrics.base_corrected_intensity_metrics_at(self, n)

    def set_version(self, version):
        return _py_interop_metrics.base_corrected_intensity_metrics_set_version(self, version)

    def keys(self):
        return _py_interop_metrics.base_corrected_intensity_metrics_keys(self)

    def lanes(self):
        return _py_interop_metrics.base_corrected_intensity_metrics_lanes(self)

    def lane_count(self):
        return _py_interop_metrics.base_corrected_intensity_metrics_lane_count(self)

    def max_lane(self):
        return _py_interop_metrics.base_corrected_intensity_metrics_max_lane(self)

    def tile_numbers_for_lane(self, lane):
        return _py_interop_metrics.base_corrected_intensity_metrics_tile_numbers_for_lane(self, lane)

    def tile_numbers(self):
        return _py_interop_metrics.base_corrected_intensity_metrics_tile_numbers(self)

    def metrics_for_lane(self, *args):
        return _py_interop_metrics.base_corrected_intensity_metrics_metrics_for_lane(self, *args)

    def cycles(self):
        return _py_interop_metrics.base_corrected_intensity_metrics_cycles(self)

    def metrics_for_cycle(self, cycle):
        return _py_interop_metrics.base_corrected_intensity_metrics_metrics_for_cycle(self, cycle)

    def size(self):
        return _py_interop_metrics.base_corrected_intensity_metrics_size(self)

    def empty(self):
        return _py_interop_metrics.base_corrected_intensity_metrics_empty(self)

    def version(self):
        return _py_interop_metrics.base_corrected_intensity_metrics_version(self)

    def clear(self):
        return _py_interop_metrics.base_corrected_intensity_metrics_clear(self)

    def metrics(self):
        return _py_interop_metrics.base_corrected_intensity_metrics_metrics(self)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.base_corrected_intensity_metrics_prefix)
    else:
        prefix = _py_interop_metrics.base_corrected_intensity_metrics_prefix
    if _newclass:
        suffix = staticmethod(_py_interop_metrics.base_corrected_intensity_metrics_suffix)
    else:
        suffix = _py_interop_metrics.base_corrected_intensity_metrics_suffix

    def get_metric_ref(self, *args):
        return _py_interop_metrics.base_corrected_intensity_metrics_get_metric_ref(self, *args)
    __swig_destroy__ = _py_interop_metrics.delete_base_corrected_intensity_metrics
    __del__ = lambda self: None
base_corrected_intensity_metrics_swigregister = _py_interop_metrics.base_corrected_intensity_metrics_swigregister
base_corrected_intensity_metrics_swigregister(base_corrected_intensity_metrics)

def base_corrected_intensity_metrics_prefix():
    return _py_interop_metrics.base_corrected_intensity_metrics_prefix()
base_corrected_intensity_metrics_prefix = _py_interop_metrics.base_corrected_intensity_metrics_prefix

def base_corrected_intensity_metrics_suffix():
    return _py_interop_metrics.base_corrected_intensity_metrics_suffix()
base_corrected_intensity_metrics_suffix = _py_interop_metrics.base_corrected_intensity_metrics_suffix

class vector_corrected_intensity_metrics(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_corrected_intensity_metrics, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_corrected_intensity_metrics, name)
    __repr__ = _swig_repr
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _py_interop_metrics.vector_corrected_intensity_metrics___nonzero__(self)

    def __bool__(self):
        return _py_interop_metrics.vector_corrected_intensity_metrics___bool__(self)

    def __len__(self):
        return _py_interop_metrics.vector_corrected_intensity_metrics___len__(self)

    def __getslice__(self, i, j):
        return _py_interop_metrics.vector_corrected_intensity_metrics___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _py_interop_metrics.vector_corrected_intensity_metrics___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _py_interop_metrics.vector_corrected_intensity_metrics___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _py_interop_metrics.vector_corrected_intensity_metrics___delitem__(self, *args)

    def __getitem__(self, *args):
        return _py_interop_metrics.vector_corrected_intensity_metrics___getitem__(self, *args)

    def __setitem__(self, *args):
        return _py_interop_metrics.vector_corrected_intensity_metrics___setitem__(self, *args)

    def pop(self):
        return _py_interop_metrics.vector_corrected_intensity_metrics_pop(self)

    def append(self, x):
        return _py_interop_metrics.vector_corrected_intensity_metrics_append(self, x)

    def empty(self):
        return _py_interop_metrics.vector_corrected_intensity_metrics_empty(self)

    def size(self):
        return _py_interop_metrics.vector_corrected_intensity_metrics_size(self)

    def swap(self, v):
        return _py_interop_metrics.vector_corrected_intensity_metrics_swap(self, v)

    def rbegin(self):
        return _py_interop_metrics.vector_corrected_intensity_metrics_rbegin(self)

    def rend(self):
        return _py_interop_metrics.vector_corrected_intensity_metrics_rend(self)

    def clear(self):
        return _py_interop_metrics.vector_corrected_intensity_metrics_clear(self)

    def get_allocator(self):
        return _py_interop_metrics.vector_corrected_intensity_metrics_get_allocator(self)

    def pop_back(self):
        return _py_interop_metrics.vector_corrected_intensity_metrics_pop_back(self)

    def erase(self, *args):
        return _py_interop_metrics.vector_corrected_intensity_metrics_erase(self, *args)

    def __init__(self, *args):
        this = _py_interop_metrics.new_vector_corrected_intensity_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _py_interop_metrics.vector_corrected_intensity_metrics_push_back(self, x)

    def front(self):
        return _py_interop_metrics.vector_corrected_intensity_metrics_front(self)

    def back(self):
        return _py_interop_metrics.vector_corrected_intensity_metrics_back(self)

    def assign(self, n, x):
        return _py_interop_metrics.vector_corrected_intensity_metrics_assign(self, n, x)

    def resize(self, *args):
        return _py_interop_metrics.vector_corrected_intensity_metrics_resize(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.vector_corrected_intensity_metrics_insert(self, *args)

    def reserve(self, n):
        return _py_interop_metrics.vector_corrected_intensity_metrics_reserve(self, n)

    def capacity(self):
        return _py_interop_metrics.vector_corrected_intensity_metrics_capacity(self)
    __swig_destroy__ = _py_interop_metrics.delete_vector_corrected_intensity_metrics
    __del__ = lambda self: None
vector_corrected_intensity_metrics_swigregister = _py_interop_metrics.vector_corrected_intensity_metrics_swigregister
vector_corrected_intensity_metrics_swigregister(vector_corrected_intensity_metrics)

class base_error_metrics(base_cycle_metric_header):
    __swig_setmethods__ = {}
    for _s in [base_cycle_metric_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, base_error_metrics, name, value)
    __swig_getmethods__ = {}
    for _s in [base_cycle_metric_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, base_error_metrics, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.base_error_metrics_TYPE
    LATEST_VERSION = _py_interop_metrics.base_error_metrics_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_base_error_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def data_source_exists(self, *args):
        return _py_interop_metrics.base_error_metrics_data_source_exists(self, *args)

    def rebuild_index(self, update_ids=False):
        return _py_interop_metrics.base_error_metrics_rebuild_index(self, update_ids)

    def resize(self, n):
        return _py_interop_metrics.base_error_metrics_resize(self, n)

    def reserve(self, n):
        return _py_interop_metrics.base_error_metrics_reserve(self, n)

    def trim(self, n):
        return _py_interop_metrics.base_error_metrics_trim(self, n)

    def find(self, *args):
        return _py_interop_metrics.base_error_metrics_find(self, *args)

    def has_metric(self, *args):
        return _py_interop_metrics.base_error_metrics_has_metric(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.base_error_metrics_insert(self, *args)

    def get_metric(self, *args):
        return _py_interop_metrics.base_error_metrics_get_metric(self, *args)

    def at(self, n):
        return _py_interop_metrics.base_error_metrics_at(self, n)

    def set_version(self, version):
        return _py_interop_metrics.base_error_metrics_set_version(self, version)

    def keys(self):
        return _py_interop_metrics.base_error_metrics_keys(self)

    def lanes(self):
        return _py_interop_metrics.base_error_metrics_lanes(self)

    def lane_count(self):
        return _py_interop_metrics.base_error_metrics_lane_count(self)

    def max_lane(self):
        return _py_interop_metrics.base_error_metrics_max_lane(self)

    def tile_numbers_for_lane(self, lane):
        return _py_interop_metrics.base_error_metrics_tile_numbers_for_lane(self, lane)

    def tile_numbers(self):
        return _py_interop_metrics.base_error_metrics_tile_numbers(self)

    def metrics_for_lane(self, *args):
        return _py_interop_metrics.base_error_metrics_metrics_for_lane(self, *args)

    def cycles(self):
        return _py_interop_metrics.base_error_metrics_cycles(self)

    def metrics_for_cycle(self, cycle):
        return _py_interop_metrics.base_error_metrics_metrics_for_cycle(self, cycle)

    def size(self):
        return _py_interop_metrics.base_error_metrics_size(self)

    def empty(self):
        return _py_interop_metrics.base_error_metrics_empty(self)

    def version(self):
        return _py_interop_metrics.base_error_metrics_version(self)

    def clear(self):
        return _py_interop_metrics.base_error_metrics_clear(self)

    def metrics(self):
        return _py_interop_metrics.base_error_metrics_metrics(self)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.base_error_metrics_prefix)
    else:
        prefix = _py_interop_metrics.base_error_metrics_prefix
    if _newclass:
        suffix = staticmethod(_py_interop_metrics.base_error_metrics_suffix)
    else:
        suffix = _py_interop_metrics.base_error_metrics_suffix

    def get_metric_ref(self, *args):
        return _py_interop_metrics.base_error_metrics_get_metric_ref(self, *args)
    __swig_destroy__ = _py_interop_metrics.delete_base_error_metrics
    __del__ = lambda self: None
base_error_metrics_swigregister = _py_interop_metrics.base_error_metrics_swigregister
base_error_metrics_swigregister(base_error_metrics)

def base_error_metrics_prefix():
    return _py_interop_metrics.base_error_metrics_prefix()
base_error_metrics_prefix = _py_interop_metrics.base_error_metrics_prefix

def base_error_metrics_suffix():
    return _py_interop_metrics.base_error_metrics_suffix()
base_error_metrics_suffix = _py_interop_metrics.base_error_metrics_suffix

class vector_error_metrics(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_error_metrics, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_error_metrics, name)
    __repr__ = _swig_repr
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _py_interop_metrics.vector_error_metrics___nonzero__(self)

    def __bool__(self):
        return _py_interop_metrics.vector_error_metrics___bool__(self)

    def __len__(self):
        return _py_interop_metrics.vector_error_metrics___len__(self)

    def __getslice__(self, i, j):
        return _py_interop_metrics.vector_error_metrics___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _py_interop_metrics.vector_error_metrics___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _py_interop_metrics.vector_error_metrics___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _py_interop_metrics.vector_error_metrics___delitem__(self, *args)

    def __getitem__(self, *args):
        return _py_interop_metrics.vector_error_metrics___getitem__(self, *args)

    def __setitem__(self, *args):
        return _py_interop_metrics.vector_error_metrics___setitem__(self, *args)

    def pop(self):
        return _py_interop_metrics.vector_error_metrics_pop(self)

    def append(self, x):
        return _py_interop_metrics.vector_error_metrics_append(self, x)

    def empty(self):
        return _py_interop_metrics.vector_error_metrics_empty(self)

    def size(self):
        return _py_interop_metrics.vector_error_metrics_size(self)

    def swap(self, v):
        return _py_interop_metrics.vector_error_metrics_swap(self, v)

    def rbegin(self):
        return _py_interop_metrics.vector_error_metrics_rbegin(self)

    def rend(self):
        return _py_interop_metrics.vector_error_metrics_rend(self)

    def clear(self):
        return _py_interop_metrics.vector_error_metrics_clear(self)

    def get_allocator(self):
        return _py_interop_metrics.vector_error_metrics_get_allocator(self)

    def pop_back(self):
        return _py_interop_metrics.vector_error_metrics_pop_back(self)

    def erase(self, *args):
        return _py_interop_metrics.vector_error_metrics_erase(self, *args)

    def __init__(self, *args):
        this = _py_interop_metrics.new_vector_error_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _py_interop_metrics.vector_error_metrics_push_back(self, x)

    def front(self):
        return _py_interop_metrics.vector_error_metrics_front(self)

    def back(self):
        return _py_interop_metrics.vector_error_metrics_back(self)

    def assign(self, n, x):
        return _py_interop_metrics.vector_error_metrics_assign(self, n, x)

    def resize(self, *args):
        return _py_interop_metrics.vector_error_metrics_resize(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.vector_error_metrics_insert(self, *args)

    def reserve(self, n):
        return _py_interop_metrics.vector_error_metrics_reserve(self, n)

    def capacity(self):
        return _py_interop_metrics.vector_error_metrics_capacity(self)
    __swig_destroy__ = _py_interop_metrics.delete_vector_error_metrics
    __del__ = lambda self: None
vector_error_metrics_swigregister = _py_interop_metrics.vector_error_metrics_swigregister
vector_error_metrics_swigregister(vector_error_metrics)

class base_extraction_metrics(extraction_metric_header):
    __swig_setmethods__ = {}
    for _s in [extraction_metric_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, base_extraction_metrics, name, value)
    __swig_getmethods__ = {}
    for _s in [extraction_metric_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, base_extraction_metrics, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.base_extraction_metrics_TYPE
    LATEST_VERSION = _py_interop_metrics.base_extraction_metrics_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_base_extraction_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def data_source_exists(self, *args):
        return _py_interop_metrics.base_extraction_metrics_data_source_exists(self, *args)

    def rebuild_index(self, update_ids=False):
        return _py_interop_metrics.base_extraction_metrics_rebuild_index(self, update_ids)

    def resize(self, n):
        return _py_interop_metrics.base_extraction_metrics_resize(self, n)

    def reserve(self, n):
        return _py_interop_metrics.base_extraction_metrics_reserve(self, n)

    def trim(self, n):
        return _py_interop_metrics.base_extraction_metrics_trim(self, n)

    def find(self, *args):
        return _py_interop_metrics.base_extraction_metrics_find(self, *args)

    def has_metric(self, *args):
        return _py_interop_metrics.base_extraction_metrics_has_metric(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.base_extraction_metrics_insert(self, *args)

    def get_metric(self, *args):
        return _py_interop_metrics.base_extraction_metrics_get_metric(self, *args)

    def at(self, n):
        return _py_interop_metrics.base_extraction_metrics_at(self, n)

    def set_version(self, version):
        return _py_interop_metrics.base_extraction_metrics_set_version(self, version)

    def keys(self):
        return _py_interop_metrics.base_extraction_metrics_keys(self)

    def lanes(self):
        return _py_interop_metrics.base_extraction_metrics_lanes(self)

    def lane_count(self):
        return _py_interop_metrics.base_extraction_metrics_lane_count(self)

    def max_lane(self):
        return _py_interop_metrics.base_extraction_metrics_max_lane(self)

    def tile_numbers_for_lane(self, lane):
        return _py_interop_metrics.base_extraction_metrics_tile_numbers_for_lane(self, lane)

    def tile_numbers(self):
        return _py_interop_metrics.base_extraction_metrics_tile_numbers(self)

    def metrics_for_lane(self, *args):
        return _py_interop_metrics.base_extraction_metrics_metrics_for_lane(self, *args)

    def cycles(self):
        return _py_interop_metrics.base_extraction_metrics_cycles(self)

    def metrics_for_cycle(self, cycle):
        return _py_interop_metrics.base_extraction_metrics_metrics_for_cycle(self, cycle)

    def size(self):
        return _py_interop_metrics.base_extraction_metrics_size(self)

    def empty(self):
        return _py_interop_metrics.base_extraction_metrics_empty(self)

    def version(self):
        return _py_interop_metrics.base_extraction_metrics_version(self)

    def clear(self):
        return _py_interop_metrics.base_extraction_metrics_clear(self)

    def metrics(self):
        return _py_interop_metrics.base_extraction_metrics_metrics(self)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.base_extraction_metrics_prefix)
    else:
        prefix = _py_interop_metrics.base_extraction_metrics_prefix
    if _newclass:
        suffix = staticmethod(_py_interop_metrics.base_extraction_metrics_suffix)
    else:
        suffix = _py_interop_metrics.base_extraction_metrics_suffix

    def get_metric_ref(self, *args):
        return _py_interop_metrics.base_extraction_metrics_get_metric_ref(self, *args)
    __swig_destroy__ = _py_interop_metrics.delete_base_extraction_metrics
    __del__ = lambda self: None
base_extraction_metrics_swigregister = _py_interop_metrics.base_extraction_metrics_swigregister
base_extraction_metrics_swigregister(base_extraction_metrics)

def base_extraction_metrics_prefix():
    return _py_interop_metrics.base_extraction_metrics_prefix()
base_extraction_metrics_prefix = _py_interop_metrics.base_extraction_metrics_prefix

def base_extraction_metrics_suffix():
    return _py_interop_metrics.base_extraction_metrics_suffix()
base_extraction_metrics_suffix = _py_interop_metrics.base_extraction_metrics_suffix

class vector_extraction_metrics(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_extraction_metrics, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_extraction_metrics, name)
    __repr__ = _swig_repr
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _py_interop_metrics.vector_extraction_metrics___nonzero__(self)

    def __bool__(self):
        return _py_interop_metrics.vector_extraction_metrics___bool__(self)

    def __len__(self):
        return _py_interop_metrics.vector_extraction_metrics___len__(self)

    def __getslice__(self, i, j):
        return _py_interop_metrics.vector_extraction_metrics___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _py_interop_metrics.vector_extraction_metrics___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _py_interop_metrics.vector_extraction_metrics___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _py_interop_metrics.vector_extraction_metrics___delitem__(self, *args)

    def __getitem__(self, *args):
        return _py_interop_metrics.vector_extraction_metrics___getitem__(self, *args)

    def __setitem__(self, *args):
        return _py_interop_metrics.vector_extraction_metrics___setitem__(self, *args)

    def pop(self):
        return _py_interop_metrics.vector_extraction_metrics_pop(self)

    def append(self, x):
        return _py_interop_metrics.vector_extraction_metrics_append(self, x)

    def empty(self):
        return _py_interop_metrics.vector_extraction_metrics_empty(self)

    def size(self):
        return _py_interop_metrics.vector_extraction_metrics_size(self)

    def swap(self, v):
        return _py_interop_metrics.vector_extraction_metrics_swap(self, v)

    def rbegin(self):
        return _py_interop_metrics.vector_extraction_metrics_rbegin(self)

    def rend(self):
        return _py_interop_metrics.vector_extraction_metrics_rend(self)

    def clear(self):
        return _py_interop_metrics.vector_extraction_metrics_clear(self)

    def get_allocator(self):
        return _py_interop_metrics.vector_extraction_metrics_get_allocator(self)

    def pop_back(self):
        return _py_interop_metrics.vector_extraction_metrics_pop_back(self)

    def erase(self, *args):
        return _py_interop_metrics.vector_extraction_metrics_erase(self, *args)

    def __init__(self, *args):
        this = _py_interop_metrics.new_vector_extraction_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _py_interop_metrics.vector_extraction_metrics_push_back(self, x)

    def front(self):
        return _py_interop_metrics.vector_extraction_metrics_front(self)

    def back(self):
        return _py_interop_metrics.vector_extraction_metrics_back(self)

    def assign(self, n, x):
        return _py_interop_metrics.vector_extraction_metrics_assign(self, n, x)

    def resize(self, *args):
        return _py_interop_metrics.vector_extraction_metrics_resize(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.vector_extraction_metrics_insert(self, *args)

    def reserve(self, n):
        return _py_interop_metrics.vector_extraction_metrics_reserve(self, n)

    def capacity(self):
        return _py_interop_metrics.vector_extraction_metrics_capacity(self)
    __swig_destroy__ = _py_interop_metrics.delete_vector_extraction_metrics
    __del__ = lambda self: None
vector_extraction_metrics_swigregister = _py_interop_metrics.vector_extraction_metrics_swigregister
vector_extraction_metrics_swigregister(vector_extraction_metrics)

class base_image_metrics(image_metric_header):
    __swig_setmethods__ = {}
    for _s in [image_metric_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, base_image_metrics, name, value)
    __swig_getmethods__ = {}
    for _s in [image_metric_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, base_image_metrics, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.base_image_metrics_TYPE
    LATEST_VERSION = _py_interop_metrics.base_image_metrics_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_base_image_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def data_source_exists(self, *args):
        return _py_interop_metrics.base_image_metrics_data_source_exists(self, *args)

    def rebuild_index(self, update_ids=False):
        return _py_interop_metrics.base_image_metrics_rebuild_index(self, update_ids)

    def resize(self, n):
        return _py_interop_metrics.base_image_metrics_resize(self, n)

    def reserve(self, n):
        return _py_interop_metrics.base_image_metrics_reserve(self, n)

    def trim(self, n):
        return _py_interop_metrics.base_image_metrics_trim(self, n)

    def find(self, *args):
        return _py_interop_metrics.base_image_metrics_find(self, *args)

    def has_metric(self, *args):
        return _py_interop_metrics.base_image_metrics_has_metric(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.base_image_metrics_insert(self, *args)

    def get_metric(self, *args):
        return _py_interop_metrics.base_image_metrics_get_metric(self, *args)

    def at(self, n):
        return _py_interop_metrics.base_image_metrics_at(self, n)

    def set_version(self, version):
        return _py_interop_metrics.base_image_metrics_set_version(self, version)

    def keys(self):
        return _py_interop_metrics.base_image_metrics_keys(self)

    def lanes(self):
        return _py_interop_metrics.base_image_metrics_lanes(self)

    def lane_count(self):
        return _py_interop_metrics.base_image_metrics_lane_count(self)

    def max_lane(self):
        return _py_interop_metrics.base_image_metrics_max_lane(self)

    def tile_numbers_for_lane(self, lane):
        return _py_interop_metrics.base_image_metrics_tile_numbers_for_lane(self, lane)

    def tile_numbers(self):
        return _py_interop_metrics.base_image_metrics_tile_numbers(self)

    def metrics_for_lane(self, *args):
        return _py_interop_metrics.base_image_metrics_metrics_for_lane(self, *args)

    def cycles(self):
        return _py_interop_metrics.base_image_metrics_cycles(self)

    def metrics_for_cycle(self, cycle):
        return _py_interop_metrics.base_image_metrics_metrics_for_cycle(self, cycle)

    def size(self):
        return _py_interop_metrics.base_image_metrics_size(self)

    def empty(self):
        return _py_interop_metrics.base_image_metrics_empty(self)

    def version(self):
        return _py_interop_metrics.base_image_metrics_version(self)

    def clear(self):
        return _py_interop_metrics.base_image_metrics_clear(self)

    def metrics(self):
        return _py_interop_metrics.base_image_metrics_metrics(self)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.base_image_metrics_prefix)
    else:
        prefix = _py_interop_metrics.base_image_metrics_prefix
    if _newclass:
        suffix = staticmethod(_py_interop_metrics.base_image_metrics_suffix)
    else:
        suffix = _py_interop_metrics.base_image_metrics_suffix

    def get_metric_ref(self, *args):
        return _py_interop_metrics.base_image_metrics_get_metric_ref(self, *args)
    __swig_destroy__ = _py_interop_metrics.delete_base_image_metrics
    __del__ = lambda self: None
base_image_metrics_swigregister = _py_interop_metrics.base_image_metrics_swigregister
base_image_metrics_swigregister(base_image_metrics)

def base_image_metrics_prefix():
    return _py_interop_metrics.base_image_metrics_prefix()
base_image_metrics_prefix = _py_interop_metrics.base_image_metrics_prefix

def base_image_metrics_suffix():
    return _py_interop_metrics.base_image_metrics_suffix()
base_image_metrics_suffix = _py_interop_metrics.base_image_metrics_suffix

class vector_image_metrics(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_image_metrics, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_image_metrics, name)
    __repr__ = _swig_repr
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _py_interop_metrics.vector_image_metrics___nonzero__(self)

    def __bool__(self):
        return _py_interop_metrics.vector_image_metrics___bool__(self)

    def __len__(self):
        return _py_interop_metrics.vector_image_metrics___len__(self)

    def __getslice__(self, i, j):
        return _py_interop_metrics.vector_image_metrics___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _py_interop_metrics.vector_image_metrics___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _py_interop_metrics.vector_image_metrics___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _py_interop_metrics.vector_image_metrics___delitem__(self, *args)

    def __getitem__(self, *args):
        return _py_interop_metrics.vector_image_metrics___getitem__(self, *args)

    def __setitem__(self, *args):
        return _py_interop_metrics.vector_image_metrics___setitem__(self, *args)

    def pop(self):
        return _py_interop_metrics.vector_image_metrics_pop(self)

    def append(self, x):
        return _py_interop_metrics.vector_image_metrics_append(self, x)

    def empty(self):
        return _py_interop_metrics.vector_image_metrics_empty(self)

    def size(self):
        return _py_interop_metrics.vector_image_metrics_size(self)

    def swap(self, v):
        return _py_interop_metrics.vector_image_metrics_swap(self, v)

    def rbegin(self):
        return _py_interop_metrics.vector_image_metrics_rbegin(self)

    def rend(self):
        return _py_interop_metrics.vector_image_metrics_rend(self)

    def clear(self):
        return _py_interop_metrics.vector_image_metrics_clear(self)

    def get_allocator(self):
        return _py_interop_metrics.vector_image_metrics_get_allocator(self)

    def pop_back(self):
        return _py_interop_metrics.vector_image_metrics_pop_back(self)

    def erase(self, *args):
        return _py_interop_metrics.vector_image_metrics_erase(self, *args)

    def __init__(self, *args):
        this = _py_interop_metrics.new_vector_image_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _py_interop_metrics.vector_image_metrics_push_back(self, x)

    def front(self):
        return _py_interop_metrics.vector_image_metrics_front(self)

    def back(self):
        return _py_interop_metrics.vector_image_metrics_back(self)

    def assign(self, n, x):
        return _py_interop_metrics.vector_image_metrics_assign(self, n, x)

    def resize(self, *args):
        return _py_interop_metrics.vector_image_metrics_resize(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.vector_image_metrics_insert(self, *args)

    def reserve(self, n):
        return _py_interop_metrics.vector_image_metrics_reserve(self, n)

    def capacity(self):
        return _py_interop_metrics.vector_image_metrics_capacity(self)
    __swig_destroy__ = _py_interop_metrics.delete_vector_image_metrics
    __del__ = lambda self: None
vector_image_metrics_swigregister = _py_interop_metrics.vector_image_metrics_swigregister
vector_image_metrics_swigregister(vector_image_metrics)

class base_q_metrics(q_score_header):
    __swig_setmethods__ = {}
    for _s in [q_score_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, base_q_metrics, name, value)
    __swig_getmethods__ = {}
    for _s in [q_score_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, base_q_metrics, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.base_q_metrics_TYPE
    LATEST_VERSION = _py_interop_metrics.base_q_metrics_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_base_q_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def data_source_exists(self, *args):
        return _py_interop_metrics.base_q_metrics_data_source_exists(self, *args)

    def rebuild_index(self, update_ids=False):
        return _py_interop_metrics.base_q_metrics_rebuild_index(self, update_ids)

    def resize(self, n):
        return _py_interop_metrics.base_q_metrics_resize(self, n)

    def reserve(self, n):
        return _py_interop_metrics.base_q_metrics_reserve(self, n)

    def trim(self, n):
        return _py_interop_metrics.base_q_metrics_trim(self, n)

    def find(self, *args):
        return _py_interop_metrics.base_q_metrics_find(self, *args)

    def has_metric(self, *args):
        return _py_interop_metrics.base_q_metrics_has_metric(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.base_q_metrics_insert(self, *args)

    def get_metric(self, *args):
        return _py_interop_metrics.base_q_metrics_get_metric(self, *args)

    def at(self, n):
        return _py_interop_metrics.base_q_metrics_at(self, n)

    def set_version(self, version):
        return _py_interop_metrics.base_q_metrics_set_version(self, version)

    def keys(self):
        return _py_interop_metrics.base_q_metrics_keys(self)

    def lanes(self):
        return _py_interop_metrics.base_q_metrics_lanes(self)

    def lane_count(self):
        return _py_interop_metrics.base_q_metrics_lane_count(self)

    def max_lane(self):
        return _py_interop_metrics.base_q_metrics_max_lane(self)

    def tile_numbers_for_lane(self, lane):
        return _py_interop_metrics.base_q_metrics_tile_numbers_for_lane(self, lane)

    def tile_numbers(self):
        return _py_interop_metrics.base_q_metrics_tile_numbers(self)

    def metrics_for_lane(self, *args):
        return _py_interop_metrics.base_q_metrics_metrics_for_lane(self, *args)

    def cycles(self):
        return _py_interop_metrics.base_q_metrics_cycles(self)

    def metrics_for_cycle(self, cycle):
        return _py_interop_metrics.base_q_metrics_metrics_for_cycle(self, cycle)

    def size(self):
        return _py_interop_metrics.base_q_metrics_size(self)

    def empty(self):
        return _py_interop_metrics.base_q_metrics_empty(self)

    def version(self):
        return _py_interop_metrics.base_q_metrics_version(self)

    def clear(self):
        return _py_interop_metrics.base_q_metrics_clear(self)

    def metrics(self):
        return _py_interop_metrics.base_q_metrics_metrics(self)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.base_q_metrics_prefix)
    else:
        prefix = _py_interop_metrics.base_q_metrics_prefix
    if _newclass:
        suffix = staticmethod(_py_interop_metrics.base_q_metrics_suffix)
    else:
        suffix = _py_interop_metrics.base_q_metrics_suffix

    def get_metric_ref(self, *args):
        return _py_interop_metrics.base_q_metrics_get_metric_ref(self, *args)
    __swig_destroy__ = _py_interop_metrics.delete_base_q_metrics
    __del__ = lambda self: None
base_q_metrics_swigregister = _py_interop_metrics.base_q_metrics_swigregister
base_q_metrics_swigregister(base_q_metrics)

def base_q_metrics_prefix():
    return _py_interop_metrics.base_q_metrics_prefix()
base_q_metrics_prefix = _py_interop_metrics.base_q_metrics_prefix

def base_q_metrics_suffix():
    return _py_interop_metrics.base_q_metrics_suffix()
base_q_metrics_suffix = _py_interop_metrics.base_q_metrics_suffix

class vector_q_metrics(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_q_metrics, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_q_metrics, name)
    __repr__ = _swig_repr
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _py_interop_metrics.vector_q_metrics___nonzero__(self)

    def __bool__(self):
        return _py_interop_metrics.vector_q_metrics___bool__(self)

    def __len__(self):
        return _py_interop_metrics.vector_q_metrics___len__(self)

    def __getslice__(self, i, j):
        return _py_interop_metrics.vector_q_metrics___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _py_interop_metrics.vector_q_metrics___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _py_interop_metrics.vector_q_metrics___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _py_interop_metrics.vector_q_metrics___delitem__(self, *args)

    def __getitem__(self, *args):
        return _py_interop_metrics.vector_q_metrics___getitem__(self, *args)

    def __setitem__(self, *args):
        return _py_interop_metrics.vector_q_metrics___setitem__(self, *args)

    def pop(self):
        return _py_interop_metrics.vector_q_metrics_pop(self)

    def append(self, x):
        return _py_interop_metrics.vector_q_metrics_append(self, x)

    def empty(self):
        return _py_interop_metrics.vector_q_metrics_empty(self)

    def size(self):
        return _py_interop_metrics.vector_q_metrics_size(self)

    def swap(self, v):
        return _py_interop_metrics.vector_q_metrics_swap(self, v)

    def rbegin(self):
        return _py_interop_metrics.vector_q_metrics_rbegin(self)

    def rend(self):
        return _py_interop_metrics.vector_q_metrics_rend(self)

    def clear(self):
        return _py_interop_metrics.vector_q_metrics_clear(self)

    def get_allocator(self):
        return _py_interop_metrics.vector_q_metrics_get_allocator(self)

    def pop_back(self):
        return _py_interop_metrics.vector_q_metrics_pop_back(self)

    def erase(self, *args):
        return _py_interop_metrics.vector_q_metrics_erase(self, *args)

    def __init__(self, *args):
        this = _py_interop_metrics.new_vector_q_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _py_interop_metrics.vector_q_metrics_push_back(self, x)

    def front(self):
        return _py_interop_metrics.vector_q_metrics_front(self)

    def back(self):
        return _py_interop_metrics.vector_q_metrics_back(self)

    def assign(self, n, x):
        return _py_interop_metrics.vector_q_metrics_assign(self, n, x)

    def resize(self, *args):
        return _py_interop_metrics.vector_q_metrics_resize(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.vector_q_metrics_insert(self, *args)

    def reserve(self, n):
        return _py_interop_metrics.vector_q_metrics_reserve(self, n)

    def capacity(self):
        return _py_interop_metrics.vector_q_metrics_capacity(self)
    __swig_destroy__ = _py_interop_metrics.delete_vector_q_metrics
    __del__ = lambda self: None
vector_q_metrics_swigregister = _py_interop_metrics.vector_q_metrics_swigregister
vector_q_metrics_swigregister(vector_q_metrics)

class base_tile_metrics(tile_metric_header):
    __swig_setmethods__ = {}
    for _s in [tile_metric_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, base_tile_metrics, name, value)
    __swig_getmethods__ = {}
    for _s in [tile_metric_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, base_tile_metrics, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.base_tile_metrics_TYPE
    LATEST_VERSION = _py_interop_metrics.base_tile_metrics_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_base_tile_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def data_source_exists(self, *args):
        return _py_interop_metrics.base_tile_metrics_data_source_exists(self, *args)

    def rebuild_index(self, update_ids=False):
        return _py_interop_metrics.base_tile_metrics_rebuild_index(self, update_ids)

    def resize(self, n):
        return _py_interop_metrics.base_tile_metrics_resize(self, n)

    def reserve(self, n):
        return _py_interop_metrics.base_tile_metrics_reserve(self, n)

    def trim(self, n):
        return _py_interop_metrics.base_tile_metrics_trim(self, n)

    def find(self, *args):
        return _py_interop_metrics.base_tile_metrics_find(self, *args)

    def has_metric(self, *args):
        return _py_interop_metrics.base_tile_metrics_has_metric(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.base_tile_metrics_insert(self, *args)

    def get_metric(self, *args):
        return _py_interop_metrics.base_tile_metrics_get_metric(self, *args)

    def at(self, n):
        return _py_interop_metrics.base_tile_metrics_at(self, n)

    def set_version(self, version):
        return _py_interop_metrics.base_tile_metrics_set_version(self, version)

    def keys(self):
        return _py_interop_metrics.base_tile_metrics_keys(self)

    def lanes(self):
        return _py_interop_metrics.base_tile_metrics_lanes(self)

    def lane_count(self):
        return _py_interop_metrics.base_tile_metrics_lane_count(self)

    def max_lane(self):
        return _py_interop_metrics.base_tile_metrics_max_lane(self)

    def tile_numbers_for_lane(self, lane):
        return _py_interop_metrics.base_tile_metrics_tile_numbers_for_lane(self, lane)

    def tile_numbers(self):
        return _py_interop_metrics.base_tile_metrics_tile_numbers(self)

    def metrics_for_lane(self, *args):
        return _py_interop_metrics.base_tile_metrics_metrics_for_lane(self, *args)

    def cycles(self):
        return _py_interop_metrics.base_tile_metrics_cycles(self)

    def metrics_for_cycle(self, cycle):
        return _py_interop_metrics.base_tile_metrics_metrics_for_cycle(self, cycle)

    def size(self):
        return _py_interop_metrics.base_tile_metrics_size(self)

    def empty(self):
        return _py_interop_metrics.base_tile_metrics_empty(self)

    def version(self):
        return _py_interop_metrics.base_tile_metrics_version(self)

    def clear(self):
        return _py_interop_metrics.base_tile_metrics_clear(self)

    def metrics(self):
        return _py_interop_metrics.base_tile_metrics_metrics(self)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.base_tile_metrics_prefix)
    else:
        prefix = _py_interop_metrics.base_tile_metrics_prefix
    if _newclass:
        suffix = staticmethod(_py_interop_metrics.base_tile_metrics_suffix)
    else:
        suffix = _py_interop_metrics.base_tile_metrics_suffix

    def get_metric_ref(self, *args):
        return _py_interop_metrics.base_tile_metrics_get_metric_ref(self, *args)
    __swig_destroy__ = _py_interop_metrics.delete_base_tile_metrics
    __del__ = lambda self: None
base_tile_metrics_swigregister = _py_interop_metrics.base_tile_metrics_swigregister
base_tile_metrics_swigregister(base_tile_metrics)

def base_tile_metrics_prefix():
    return _py_interop_metrics.base_tile_metrics_prefix()
base_tile_metrics_prefix = _py_interop_metrics.base_tile_metrics_prefix

def base_tile_metrics_suffix():
    return _py_interop_metrics.base_tile_metrics_suffix()
base_tile_metrics_suffix = _py_interop_metrics.base_tile_metrics_suffix

class vector_tile_metrics(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_tile_metrics, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_tile_metrics, name)
    __repr__ = _swig_repr
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _py_interop_metrics.vector_tile_metrics___nonzero__(self)

    def __bool__(self):
        return _py_interop_metrics.vector_tile_metrics___bool__(self)

    def __len__(self):
        return _py_interop_metrics.vector_tile_metrics___len__(self)

    def __getslice__(self, i, j):
        return _py_interop_metrics.vector_tile_metrics___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _py_interop_metrics.vector_tile_metrics___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _py_interop_metrics.vector_tile_metrics___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _py_interop_metrics.vector_tile_metrics___delitem__(self, *args)

    def __getitem__(self, *args):
        return _py_interop_metrics.vector_tile_metrics___getitem__(self, *args)

    def __setitem__(self, *args):
        return _py_interop_metrics.vector_tile_metrics___setitem__(self, *args)

    def pop(self):
        return _py_interop_metrics.vector_tile_metrics_pop(self)

    def append(self, x):
        return _py_interop_metrics.vector_tile_metrics_append(self, x)

    def empty(self):
        return _py_interop_metrics.vector_tile_metrics_empty(self)

    def size(self):
        return _py_interop_metrics.vector_tile_metrics_size(self)

    def swap(self, v):
        return _py_interop_metrics.vector_tile_metrics_swap(self, v)

    def rbegin(self):
        return _py_interop_metrics.vector_tile_metrics_rbegin(self)

    def rend(self):
        return _py_interop_metrics.vector_tile_metrics_rend(self)

    def clear(self):
        return _py_interop_metrics.vector_tile_metrics_clear(self)

    def get_allocator(self):
        return _py_interop_metrics.vector_tile_metrics_get_allocator(self)

    def pop_back(self):
        return _py_interop_metrics.vector_tile_metrics_pop_back(self)

    def erase(self, *args):
        return _py_interop_metrics.vector_tile_metrics_erase(self, *args)

    def __init__(self, *args):
        this = _py_interop_metrics.new_vector_tile_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _py_interop_metrics.vector_tile_metrics_push_back(self, x)

    def front(self):
        return _py_interop_metrics.vector_tile_metrics_front(self)

    def back(self):
        return _py_interop_metrics.vector_tile_metrics_back(self)

    def assign(self, n, x):
        return _py_interop_metrics.vector_tile_metrics_assign(self, n, x)

    def resize(self, *args):
        return _py_interop_metrics.vector_tile_metrics_resize(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.vector_tile_metrics_insert(self, *args)

    def reserve(self, n):
        return _py_interop_metrics.vector_tile_metrics_reserve(self, n)

    def capacity(self):
        return _py_interop_metrics.vector_tile_metrics_capacity(self)
    __swig_destroy__ = _py_interop_metrics.delete_vector_tile_metrics
    __del__ = lambda self: None
vector_tile_metrics_swigregister = _py_interop_metrics.vector_tile_metrics_swigregister
vector_tile_metrics_swigregister(vector_tile_metrics)

class base_index_metrics(index_metric_header):
    __swig_setmethods__ = {}
    for _s in [index_metric_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, base_index_metrics, name, value)
    __swig_getmethods__ = {}
    for _s in [index_metric_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, base_index_metrics, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.base_index_metrics_TYPE
    LATEST_VERSION = _py_interop_metrics.base_index_metrics_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_base_index_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def data_source_exists(self, *args):
        return _py_interop_metrics.base_index_metrics_data_source_exists(self, *args)

    def rebuild_index(self, update_ids=False):
        return _py_interop_metrics.base_index_metrics_rebuild_index(self, update_ids)

    def resize(self, n):
        return _py_interop_metrics.base_index_metrics_resize(self, n)

    def reserve(self, n):
        return _py_interop_metrics.base_index_metrics_reserve(self, n)

    def trim(self, n):
        return _py_interop_metrics.base_index_metrics_trim(self, n)

    def find(self, *args):
        return _py_interop_metrics.base_index_metrics_find(self, *args)

    def has_metric(self, *args):
        return _py_interop_metrics.base_index_metrics_has_metric(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.base_index_metrics_insert(self, *args)

    def get_metric(self, *args):
        return _py_interop_metrics.base_index_metrics_get_metric(self, *args)

    def at(self, n):
        return _py_interop_metrics.base_index_metrics_at(self, n)

    def set_version(self, version):
        return _py_interop_metrics.base_index_metrics_set_version(self, version)

    def keys(self):
        return _py_interop_metrics.base_index_metrics_keys(self)

    def lanes(self):
        return _py_interop_metrics.base_index_metrics_lanes(self)

    def lane_count(self):
        return _py_interop_metrics.base_index_metrics_lane_count(self)

    def max_lane(self):
        return _py_interop_metrics.base_index_metrics_max_lane(self)

    def tile_numbers_for_lane(self, lane):
        return _py_interop_metrics.base_index_metrics_tile_numbers_for_lane(self, lane)

    def tile_numbers(self):
        return _py_interop_metrics.base_index_metrics_tile_numbers(self)

    def metrics_for_lane(self, *args):
        return _py_interop_metrics.base_index_metrics_metrics_for_lane(self, *args)

    def cycles(self):
        return _py_interop_metrics.base_index_metrics_cycles(self)

    def metrics_for_cycle(self, cycle):
        return _py_interop_metrics.base_index_metrics_metrics_for_cycle(self, cycle)

    def size(self):
        return _py_interop_metrics.base_index_metrics_size(self)

    def empty(self):
        return _py_interop_metrics.base_index_metrics_empty(self)

    def version(self):
        return _py_interop_metrics.base_index_metrics_version(self)

    def clear(self):
        return _py_interop_metrics.base_index_metrics_clear(self)

    def metrics(self):
        return _py_interop_metrics.base_index_metrics_metrics(self)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.base_index_metrics_prefix)
    else:
        prefix = _py_interop_metrics.base_index_metrics_prefix
    if _newclass:
        suffix = staticmethod(_py_interop_metrics.base_index_metrics_suffix)
    else:
        suffix = _py_interop_metrics.base_index_metrics_suffix

    def get_metric_ref(self, *args):
        return _py_interop_metrics.base_index_metrics_get_metric_ref(self, *args)
    __swig_destroy__ = _py_interop_metrics.delete_base_index_metrics
    __del__ = lambda self: None
base_index_metrics_swigregister = _py_interop_metrics.base_index_metrics_swigregister
base_index_metrics_swigregister(base_index_metrics)

def base_index_metrics_prefix():
    return _py_interop_metrics.base_index_metrics_prefix()
base_index_metrics_prefix = _py_interop_metrics.base_index_metrics_prefix

def base_index_metrics_suffix():
    return _py_interop_metrics.base_index_metrics_suffix()
base_index_metrics_suffix = _py_interop_metrics.base_index_metrics_suffix

class vector_index_metrics(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_index_metrics, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_index_metrics, name)
    __repr__ = _swig_repr
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _py_interop_metrics.vector_index_metrics___nonzero__(self)

    def __bool__(self):
        return _py_interop_metrics.vector_index_metrics___bool__(self)

    def __len__(self):
        return _py_interop_metrics.vector_index_metrics___len__(self)

    def __getslice__(self, i, j):
        return _py_interop_metrics.vector_index_metrics___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _py_interop_metrics.vector_index_metrics___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _py_interop_metrics.vector_index_metrics___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _py_interop_metrics.vector_index_metrics___delitem__(self, *args)

    def __getitem__(self, *args):
        return _py_interop_metrics.vector_index_metrics___getitem__(self, *args)

    def __setitem__(self, *args):
        return _py_interop_metrics.vector_index_metrics___setitem__(self, *args)

    def pop(self):
        return _py_interop_metrics.vector_index_metrics_pop(self)

    def append(self, x):
        return _py_interop_metrics.vector_index_metrics_append(self, x)

    def empty(self):
        return _py_interop_metrics.vector_index_metrics_empty(self)

    def size(self):
        return _py_interop_metrics.vector_index_metrics_size(self)

    def swap(self, v):
        return _py_interop_metrics.vector_index_metrics_swap(self, v)

    def rbegin(self):
        return _py_interop_metrics.vector_index_metrics_rbegin(self)

    def rend(self):
        return _py_interop_metrics.vector_index_metrics_rend(self)

    def clear(self):
        return _py_interop_metrics.vector_index_metrics_clear(self)

    def get_allocator(self):
        return _py_interop_metrics.vector_index_metrics_get_allocator(self)

    def pop_back(self):
        return _py_interop_metrics.vector_index_metrics_pop_back(self)

    def erase(self, *args):
        return _py_interop_metrics.vector_index_metrics_erase(self, *args)

    def __init__(self, *args):
        this = _py_interop_metrics.new_vector_index_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _py_interop_metrics.vector_index_metrics_push_back(self, x)

    def front(self):
        return _py_interop_metrics.vector_index_metrics_front(self)

    def back(self):
        return _py_interop_metrics.vector_index_metrics_back(self)

    def assign(self, n, x):
        return _py_interop_metrics.vector_index_metrics_assign(self, n, x)

    def resize(self, *args):
        return _py_interop_metrics.vector_index_metrics_resize(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.vector_index_metrics_insert(self, *args)

    def reserve(self, n):
        return _py_interop_metrics.vector_index_metrics_reserve(self, n)

    def capacity(self):
        return _py_interop_metrics.vector_index_metrics_capacity(self)
    __swig_destroy__ = _py_interop_metrics.delete_vector_index_metrics
    __del__ = lambda self: None
vector_index_metrics_swigregister = _py_interop_metrics.vector_index_metrics_swigregister
vector_index_metrics_swigregister(vector_index_metrics)

class base_q_collapsed_metrics(q_collapsed_header):
    __swig_setmethods__ = {}
    for _s in [q_collapsed_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, base_q_collapsed_metrics, name, value)
    __swig_getmethods__ = {}
    for _s in [q_collapsed_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, base_q_collapsed_metrics, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.base_q_collapsed_metrics_TYPE
    LATEST_VERSION = _py_interop_metrics.base_q_collapsed_metrics_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_base_q_collapsed_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def data_source_exists(self, *args):
        return _py_interop_metrics.base_q_collapsed_metrics_data_source_exists(self, *args)

    def rebuild_index(self, update_ids=False):
        return _py_interop_metrics.base_q_collapsed_metrics_rebuild_index(self, update_ids)

    def resize(self, n):
        return _py_interop_metrics.base_q_collapsed_metrics_resize(self, n)

    def reserve(self, n):
        return _py_interop_metrics.base_q_collapsed_metrics_reserve(self, n)

    def trim(self, n):
        return _py_interop_metrics.base_q_collapsed_metrics_trim(self, n)

    def find(self, *args):
        return _py_interop_metrics.base_q_collapsed_metrics_find(self, *args)

    def has_metric(self, *args):
        return _py_interop_metrics.base_q_collapsed_metrics_has_metric(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.base_q_collapsed_metrics_insert(self, *args)

    def get_metric(self, *args):
        return _py_interop_metrics.base_q_collapsed_metrics_get_metric(self, *args)

    def at(self, n):
        return _py_interop_metrics.base_q_collapsed_metrics_at(self, n)

    def set_version(self, version):
        return _py_interop_metrics.base_q_collapsed_metrics_set_version(self, version)

    def keys(self):
        return _py_interop_metrics.base_q_collapsed_metrics_keys(self)

    def lanes(self):
        return _py_interop_metrics.base_q_collapsed_metrics_lanes(self)

    def lane_count(self):
        return _py_interop_metrics.base_q_collapsed_metrics_lane_count(self)

    def max_lane(self):
        return _py_interop_metrics.base_q_collapsed_metrics_max_lane(self)

    def tile_numbers_for_lane(self, lane):
        return _py_interop_metrics.base_q_collapsed_metrics_tile_numbers_for_lane(self, lane)

    def tile_numbers(self):
        return _py_interop_metrics.base_q_collapsed_metrics_tile_numbers(self)

    def metrics_for_lane(self, *args):
        return _py_interop_metrics.base_q_collapsed_metrics_metrics_for_lane(self, *args)

    def cycles(self):
        return _py_interop_metrics.base_q_collapsed_metrics_cycles(self)

    def metrics_for_cycle(self, cycle):
        return _py_interop_metrics.base_q_collapsed_metrics_metrics_for_cycle(self, cycle)

    def size(self):
        return _py_interop_metrics.base_q_collapsed_metrics_size(self)

    def empty(self):
        return _py_interop_metrics.base_q_collapsed_metrics_empty(self)

    def version(self):
        return _py_interop_metrics.base_q_collapsed_metrics_version(self)

    def clear(self):
        return _py_interop_metrics.base_q_collapsed_metrics_clear(self)

    def metrics(self):
        return _py_interop_metrics.base_q_collapsed_metrics_metrics(self)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.base_q_collapsed_metrics_prefix)
    else:
        prefix = _py_interop_metrics.base_q_collapsed_metrics_prefix
    if _newclass:
        suffix = staticmethod(_py_interop_metrics.base_q_collapsed_metrics_suffix)
    else:
        suffix = _py_interop_metrics.base_q_collapsed_metrics_suffix

    def get_metric_ref(self, *args):
        return _py_interop_metrics.base_q_collapsed_metrics_get_metric_ref(self, *args)
    __swig_destroy__ = _py_interop_metrics.delete_base_q_collapsed_metrics
    __del__ = lambda self: None
base_q_collapsed_metrics_swigregister = _py_interop_metrics.base_q_collapsed_metrics_swigregister
base_q_collapsed_metrics_swigregister(base_q_collapsed_metrics)

def base_q_collapsed_metrics_prefix():
    return _py_interop_metrics.base_q_collapsed_metrics_prefix()
base_q_collapsed_metrics_prefix = _py_interop_metrics.base_q_collapsed_metrics_prefix

def base_q_collapsed_metrics_suffix():
    return _py_interop_metrics.base_q_collapsed_metrics_suffix()
base_q_collapsed_metrics_suffix = _py_interop_metrics.base_q_collapsed_metrics_suffix

class vector_q_collapsed_metrics(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_q_collapsed_metrics, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_q_collapsed_metrics, name)
    __repr__ = _swig_repr
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _py_interop_metrics.vector_q_collapsed_metrics___nonzero__(self)

    def __bool__(self):
        return _py_interop_metrics.vector_q_collapsed_metrics___bool__(self)

    def __len__(self):
        return _py_interop_metrics.vector_q_collapsed_metrics___len__(self)

    def __getslice__(self, i, j):
        return _py_interop_metrics.vector_q_collapsed_metrics___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _py_interop_metrics.vector_q_collapsed_metrics___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _py_interop_metrics.vector_q_collapsed_metrics___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _py_interop_metrics.vector_q_collapsed_metrics___delitem__(self, *args)

    def __getitem__(self, *args):
        return _py_interop_metrics.vector_q_collapsed_metrics___getitem__(self, *args)

    def __setitem__(self, *args):
        return _py_interop_metrics.vector_q_collapsed_metrics___setitem__(self, *args)

    def pop(self):
        return _py_interop_metrics.vector_q_collapsed_metrics_pop(self)

    def append(self, x):
        return _py_interop_metrics.vector_q_collapsed_metrics_append(self, x)

    def empty(self):
        return _py_interop_metrics.vector_q_collapsed_metrics_empty(self)

    def size(self):
        return _py_interop_metrics.vector_q_collapsed_metrics_size(self)

    def swap(self, v):
        return _py_interop_metrics.vector_q_collapsed_metrics_swap(self, v)

    def rbegin(self):
        return _py_interop_metrics.vector_q_collapsed_metrics_rbegin(self)

    def rend(self):
        return _py_interop_metrics.vector_q_collapsed_metrics_rend(self)

    def clear(self):
        return _py_interop_metrics.vector_q_collapsed_metrics_clear(self)

    def get_allocator(self):
        return _py_interop_metrics.vector_q_collapsed_metrics_get_allocator(self)

    def pop_back(self):
        return _py_interop_metrics.vector_q_collapsed_metrics_pop_back(self)

    def erase(self, *args):
        return _py_interop_metrics.vector_q_collapsed_metrics_erase(self, *args)

    def __init__(self, *args):
        this = _py_interop_metrics.new_vector_q_collapsed_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _py_interop_metrics.vector_q_collapsed_metrics_push_back(self, x)

    def front(self):
        return _py_interop_metrics.vector_q_collapsed_metrics_front(self)

    def back(self):
        return _py_interop_metrics.vector_q_collapsed_metrics_back(self)

    def assign(self, n, x):
        return _py_interop_metrics.vector_q_collapsed_metrics_assign(self, n, x)

    def resize(self, *args):
        return _py_interop_metrics.vector_q_collapsed_metrics_resize(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.vector_q_collapsed_metrics_insert(self, *args)

    def reserve(self, n):
        return _py_interop_metrics.vector_q_collapsed_metrics_reserve(self, n)

    def capacity(self):
        return _py_interop_metrics.vector_q_collapsed_metrics_capacity(self)
    __swig_destroy__ = _py_interop_metrics.delete_vector_q_collapsed_metrics
    __del__ = lambda self: None
vector_q_collapsed_metrics_swigregister = _py_interop_metrics.vector_q_collapsed_metrics_swigregister
vector_q_collapsed_metrics_swigregister(vector_q_collapsed_metrics)

class base_q_by_lane_metrics(q_score_header):
    __swig_setmethods__ = {}
    for _s in [q_score_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, base_q_by_lane_metrics, name, value)
    __swig_getmethods__ = {}
    for _s in [q_score_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, base_q_by_lane_metrics, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.base_q_by_lane_metrics_TYPE
    LATEST_VERSION = _py_interop_metrics.base_q_by_lane_metrics_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_base_q_by_lane_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def data_source_exists(self, *args):
        return _py_interop_metrics.base_q_by_lane_metrics_data_source_exists(self, *args)

    def rebuild_index(self, update_ids=False):
        return _py_interop_metrics.base_q_by_lane_metrics_rebuild_index(self, update_ids)

    def resize(self, n):
        return _py_interop_metrics.base_q_by_lane_metrics_resize(self, n)

    def reserve(self, n):
        return _py_interop_metrics.base_q_by_lane_metrics_reserve(self, n)

    def trim(self, n):
        return _py_interop_metrics.base_q_by_lane_metrics_trim(self, n)

    def find(self, *args):
        return _py_interop_metrics.base_q_by_lane_metrics_find(self, *args)

    def has_metric(self, *args):
        return _py_interop_metrics.base_q_by_lane_metrics_has_metric(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.base_q_by_lane_metrics_insert(self, *args)

    def get_metric(self, *args):
        return _py_interop_metrics.base_q_by_lane_metrics_get_metric(self, *args)

    def at(self, n):
        return _py_interop_metrics.base_q_by_lane_metrics_at(self, n)

    def set_version(self, version):
        return _py_interop_metrics.base_q_by_lane_metrics_set_version(self, version)

    def keys(self):
        return _py_interop_metrics.base_q_by_lane_metrics_keys(self)

    def lanes(self):
        return _py_interop_metrics.base_q_by_lane_metrics_lanes(self)

    def lane_count(self):
        return _py_interop_metrics.base_q_by_lane_metrics_lane_count(self)

    def max_lane(self):
        return _py_interop_metrics.base_q_by_lane_metrics_max_lane(self)

    def tile_numbers_for_lane(self, lane):
        return _py_interop_metrics.base_q_by_lane_metrics_tile_numbers_for_lane(self, lane)

    def tile_numbers(self):
        return _py_interop_metrics.base_q_by_lane_metrics_tile_numbers(self)

    def metrics_for_lane(self, *args):
        return _py_interop_metrics.base_q_by_lane_metrics_metrics_for_lane(self, *args)

    def cycles(self):
        return _py_interop_metrics.base_q_by_lane_metrics_cycles(self)

    def metrics_for_cycle(self, cycle):
        return _py_interop_metrics.base_q_by_lane_metrics_metrics_for_cycle(self, cycle)

    def size(self):
        return _py_interop_metrics.base_q_by_lane_metrics_size(self)

    def empty(self):
        return _py_interop_metrics.base_q_by_lane_metrics_empty(self)

    def version(self):
        return _py_interop_metrics.base_q_by_lane_metrics_version(self)

    def clear(self):
        return _py_interop_metrics.base_q_by_lane_metrics_clear(self)

    def metrics(self):
        return _py_interop_metrics.base_q_by_lane_metrics_metrics(self)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.base_q_by_lane_metrics_prefix)
    else:
        prefix = _py_interop_metrics.base_q_by_lane_metrics_prefix
    if _newclass:
        suffix = staticmethod(_py_interop_metrics.base_q_by_lane_metrics_suffix)
    else:
        suffix = _py_interop_metrics.base_q_by_lane_metrics_suffix

    def get_metric_ref(self, *args):
        return _py_interop_metrics.base_q_by_lane_metrics_get_metric_ref(self, *args)
    __swig_destroy__ = _py_interop_metrics.delete_base_q_by_lane_metrics
    __del__ = lambda self: None
base_q_by_lane_metrics_swigregister = _py_interop_metrics.base_q_by_lane_metrics_swigregister
base_q_by_lane_metrics_swigregister(base_q_by_lane_metrics)

def base_q_by_lane_metrics_prefix():
    return _py_interop_metrics.base_q_by_lane_metrics_prefix()
base_q_by_lane_metrics_prefix = _py_interop_metrics.base_q_by_lane_metrics_prefix

def base_q_by_lane_metrics_suffix():
    return _py_interop_metrics.base_q_by_lane_metrics_suffix()
base_q_by_lane_metrics_suffix = _py_interop_metrics.base_q_by_lane_metrics_suffix

class vector_q_by_lane_metrics(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_q_by_lane_metrics, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_q_by_lane_metrics, name)
    __repr__ = _swig_repr
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _py_interop_metrics.vector_q_by_lane_metrics___nonzero__(self)

    def __bool__(self):
        return _py_interop_metrics.vector_q_by_lane_metrics___bool__(self)

    def __len__(self):
        return _py_interop_metrics.vector_q_by_lane_metrics___len__(self)

    def __getslice__(self, i, j):
        return _py_interop_metrics.vector_q_by_lane_metrics___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _py_interop_metrics.vector_q_by_lane_metrics___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _py_interop_metrics.vector_q_by_lane_metrics___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _py_interop_metrics.vector_q_by_lane_metrics___delitem__(self, *args)

    def __getitem__(self, *args):
        return _py_interop_metrics.vector_q_by_lane_metrics___getitem__(self, *args)

    def __setitem__(self, *args):
        return _py_interop_metrics.vector_q_by_lane_metrics___setitem__(self, *args)

    def pop(self):
        return _py_interop_metrics.vector_q_by_lane_metrics_pop(self)

    def append(self, x):
        return _py_interop_metrics.vector_q_by_lane_metrics_append(self, x)

    def empty(self):
        return _py_interop_metrics.vector_q_by_lane_metrics_empty(self)

    def size(self):
        return _py_interop_metrics.vector_q_by_lane_metrics_size(self)

    def swap(self, v):
        return _py_interop_metrics.vector_q_by_lane_metrics_swap(self, v)

    def rbegin(self):
        return _py_interop_metrics.vector_q_by_lane_metrics_rbegin(self)

    def rend(self):
        return _py_interop_metrics.vector_q_by_lane_metrics_rend(self)

    def clear(self):
        return _py_interop_metrics.vector_q_by_lane_metrics_clear(self)

    def get_allocator(self):
        return _py_interop_metrics.vector_q_by_lane_metrics_get_allocator(self)

    def pop_back(self):
        return _py_interop_metrics.vector_q_by_lane_metrics_pop_back(self)

    def erase(self, *args):
        return _py_interop_metrics.vector_q_by_lane_metrics_erase(self, *args)

    def __init__(self, *args):
        this = _py_interop_metrics.new_vector_q_by_lane_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _py_interop_metrics.vector_q_by_lane_metrics_push_back(self, x)

    def front(self):
        return _py_interop_metrics.vector_q_by_lane_metrics_front(self)

    def back(self):
        return _py_interop_metrics.vector_q_by_lane_metrics_back(self)

    def assign(self, n, x):
        return _py_interop_metrics.vector_q_by_lane_metrics_assign(self, n, x)

    def resize(self, *args):
        return _py_interop_metrics.vector_q_by_lane_metrics_resize(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.vector_q_by_lane_metrics_insert(self, *args)

    def reserve(self, n):
        return _py_interop_metrics.vector_q_by_lane_metrics_reserve(self, n)

    def capacity(self):
        return _py_interop_metrics.vector_q_by_lane_metrics_capacity(self)
    __swig_destroy__ = _py_interop_metrics.delete_vector_q_by_lane_metrics
    __del__ = lambda self: None
vector_q_by_lane_metrics_swigregister = _py_interop_metrics.vector_q_by_lane_metrics_swigregister
vector_q_by_lane_metrics_swigregister(vector_q_by_lane_metrics)

class point2d_vector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, point2d_vector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, point2d_vector, name)
    __repr__ = _swig_repr
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _py_interop_metrics.point2d_vector___nonzero__(self)

    def __bool__(self):
        return _py_interop_metrics.point2d_vector___bool__(self)

    def __len__(self):
        return _py_interop_metrics.point2d_vector___len__(self)

    def __getslice__(self, i, j):
        return _py_interop_metrics.point2d_vector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _py_interop_metrics.point2d_vector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _py_interop_metrics.point2d_vector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _py_interop_metrics.point2d_vector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _py_interop_metrics.point2d_vector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _py_interop_metrics.point2d_vector___setitem__(self, *args)

    def pop(self):
        return _py_interop_metrics.point2d_vector_pop(self)

    def append(self, x):
        return _py_interop_metrics.point2d_vector_append(self, x)

    def empty(self):
        return _py_interop_metrics.point2d_vector_empty(self)

    def size(self):
        return _py_interop_metrics.point2d_vector_size(self)

    def swap(self, v):
        return _py_interop_metrics.point2d_vector_swap(self, v)

    def rbegin(self):
        return _py_interop_metrics.point2d_vector_rbegin(self)

    def rend(self):
        return _py_interop_metrics.point2d_vector_rend(self)

    def clear(self):
        return _py_interop_metrics.point2d_vector_clear(self)

    def get_allocator(self):
        return _py_interop_metrics.point2d_vector_get_allocator(self)

    def pop_back(self):
        return _py_interop_metrics.point2d_vector_pop_back(self)

    def erase(self, *args):
        return _py_interop_metrics.point2d_vector_erase(self, *args)

    def __init__(self, *args):
        this = _py_interop_metrics.new_point2d_vector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _py_interop_metrics.point2d_vector_push_back(self, x)

    def front(self):
        return _py_interop_metrics.point2d_vector_front(self)

    def back(self):
        return _py_interop_metrics.point2d_vector_back(self)

    def assign(self, n, x):
        return _py_interop_metrics.point2d_vector_assign(self, n, x)

    def resize(self, *args):
        return _py_interop_metrics.point2d_vector_resize(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.point2d_vector_insert(self, *args)

    def reserve(self, n):
        return _py_interop_metrics.point2d_vector_reserve(self, n)

    def capacity(self):
        return _py_interop_metrics.point2d_vector_capacity(self)
    __swig_destroy__ = _py_interop_metrics.delete_point2d_vector
    __del__ = lambda self: None
point2d_vector_swigregister = _py_interop_metrics.point2d_vector_swigregister
point2d_vector_swigregister(point2d_vector)

class event_metric_map(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, event_metric_map, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, event_metric_map, name)
    __repr__ = _swig_repr
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _py_interop_metrics.event_metric_map___nonzero__(self)

    def __bool__(self):
        return _py_interop_metrics.event_metric_map___bool__(self)

    def __len__(self):
        return _py_interop_metrics.event_metric_map___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        return _py_interop_metrics.event_metric_map___getitem__(self, key)

    def __delitem__(self, key):
        return _py_interop_metrics.event_metric_map___delitem__(self, key)

    def has_key(self, key):
        return _py_interop_metrics.event_metric_map_has_key(self, key)

    def keys(self):
        return _py_interop_metrics.event_metric_map_keys(self)

    def values(self):
        return _py_interop_metrics.event_metric_map_values(self)

    def items(self):
        return _py_interop_metrics.event_metric_map_items(self)

    def __contains__(self, key):
        return _py_interop_metrics.event_metric_map___contains__(self, key)

    def key_iterator(self):
        return _py_interop_metrics.event_metric_map_key_iterator(self)

    def value_iterator(self):
        return _py_interop_metrics.event_metric_map_value_iterator(self)

    def __setitem__(self, *args):
        return _py_interop_metrics.event_metric_map___setitem__(self, *args)

    def asdict(self):
        return _py_interop_metrics.event_metric_map_asdict(self)

    def __init__(self, *args):
        this = _py_interop_metrics.new_event_metric_map(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def empty(self):
        return _py_interop_metrics.event_metric_map_empty(self)

    def size(self):
        return _py_interop_metrics.event_metric_map_size(self)

    def swap(self, v):
        return _py_interop_metrics.event_metric_map_swap(self, v)

    def rbegin(self):
        return _py_interop_metrics.event_metric_map_rbegin(self)

    def rend(self):
        return _py_interop_metrics.event_metric_map_rend(self)

    def clear(self):
        return _py_interop_metrics.event_metric_map_clear(self)

    def get_allocator(self):
        return _py_interop_metrics.event_metric_map_get_allocator(self)

    def count(self, x):
        return _py_interop_metrics.event_metric_map_count(self, x)

    def erase(self, *args):
        return _py_interop_metrics.event_metric_map_erase(self, *args)

    def find(self, x):
        return _py_interop_metrics.event_metric_map_find(self, x)

    def lower_bound(self, x):
        return _py_interop_metrics.event_metric_map_lower_bound(self, x)

    def upper_bound(self, x):
        return _py_interop_metrics.event_metric_map_upper_bound(self, x)
    __swig_destroy__ = _py_interop_metrics.delete_event_metric_map
    __del__ = lambda self: None
event_metric_map_swigregister = _py_interop_metrics.event_metric_map_swigregister
event_metric_map_swigregister(event_metric_map)

class alignment_metric(base_cycle_metric):
    __swig_setmethods__ = {}
    for _s in [base_cycle_metric]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, alignment_metric, name, value)
    __swig_getmethods__ = {}
    for _s in [base_cycle_metric]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, alignment_metric, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.alignment_metric_TYPE
    LATEST_VERSION = _py_interop_metrics.alignment_metric_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_alignment_metric(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def confusion_matrix(self):
        return _py_interop_metrics.alignment_metric_confusion_matrix(self)

    def row_count(self):
        return _py_interop_metrics.alignment_metric_row_count(self)

    def column_count(self):
        return _py_interop_metrics.alignment_metric_column_count(self)

    def total_count(self):
        return _py_interop_metrics.alignment_metric_total_count(self)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.alignment_metric_prefix)
    else:
        prefix = _py_interop_metrics.alignment_metric_prefix
    __swig_destroy__ = _py_interop_metrics.delete_alignment_metric
    __del__ = lambda self: None
alignment_metric_swigregister = _py_interop_metrics.alignment_metric_swigregister
alignment_metric_swigregister(alignment_metric)

def alignment_metric_prefix():
    return _py_interop_metrics.alignment_metric_prefix()
alignment_metric_prefix = _py_interop_metrics.alignment_metric_prefix

class basecalling_metric_header(base_cycle_metric_header):
    __swig_setmethods__ = {}
    for _s in [base_cycle_metric_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, basecalling_metric_header, name, value)
    __swig_getmethods__ = {}
    for _s in [base_cycle_metric_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, basecalling_metric_header, name)
    __repr__ = _swig_repr
    CENTROIDS = _py_interop_metrics.basecalling_metric_header_CENTROIDS
    COVARIANCES = _py_interop_metrics.basecalling_metric_header_COVARIANCES
    WEIGHTS = _py_interop_metrics.basecalling_metric_header_WEIGHTS
    DETERMINANT = _py_interop_metrics.basecalling_metric_header_DETERMINANT

    def __init__(self, info_level):
        this = _py_interop_metrics.new_basecalling_metric_header(info_level)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def info_level(self):
        return _py_interop_metrics.basecalling_metric_header_info_level(self)

    def has_covariances(self):
        return _py_interop_metrics.basecalling_metric_header_has_covariances(self)

    def has_weights(self):
        return _py_interop_metrics.basecalling_metric_header_has_weights(self)

    def has_determinant(self):
        return _py_interop_metrics.basecalling_metric_header_has_determinant(self)

    def clear(self):
        return _py_interop_metrics.basecalling_metric_header_clear(self)
    if _newclass:
        default_header = staticmethod(_py_interop_metrics.basecalling_metric_header_default_header)
    else:
        default_header = _py_interop_metrics.basecalling_metric_header_default_header
    __swig_destroy__ = _py_interop_metrics.delete_basecalling_metric_header
    __del__ = lambda self: None
basecalling_metric_header_swigregister = _py_interop_metrics.basecalling_metric_header_swigregister
basecalling_metric_header_swigregister(basecalling_metric_header)

def basecalling_metric_header_default_header():
    return _py_interop_metrics.basecalling_metric_header_default_header()
basecalling_metric_header_default_header = _py_interop_metrics.basecalling_metric_header_default_header

class basecalling_metric(base_cycle_metric):
    __swig_setmethods__ = {}
    for _s in [base_cycle_metric]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, basecalling_metric, name, value)
    __swig_getmethods__ = {}
    for _s in [base_cycle_metric]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, basecalling_metric, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.basecalling_metric_TYPE
    DIM = _py_interop_metrics.basecalling_metric_DIM
    LATEST_VERSION = _py_interop_metrics.basecalling_metric_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_basecalling_metric(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def set(self, *args):
        return _py_interop_metrics.basecalling_metric_set(self, *args)

    def centroids(self):
        return _py_interop_metrics.basecalling_metric_centroids(self)

    def covariances(self):
        return _py_interop_metrics.basecalling_metric_covariances(self)

    def weights(self):
        return _py_interop_metrics.basecalling_metric_weights(self)

    def mean_determinant(self):
        return _py_interop_metrics.basecalling_metric_mean_determinant(self)

    def radius(self, base_index):
        return _py_interop_metrics.basecalling_metric_radius(self, base_index)

    def area(self):
        return _py_interop_metrics.basecalling_metric_area(self)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.basecalling_metric_prefix)
    else:
        prefix = _py_interop_metrics.basecalling_metric_prefix
    __swig_destroy__ = _py_interop_metrics.delete_basecalling_metric
    __del__ = lambda self: None
basecalling_metric_swigregister = _py_interop_metrics.basecalling_metric_swigregister
basecalling_metric_swigregister(basecalling_metric)

def basecalling_metric_prefix():
    return _py_interop_metrics.basecalling_metric_prefix()
basecalling_metric_prefix = _py_interop_metrics.basecalling_metric_prefix

class color_matrix_metric_header(base_cycle_metric_header):
    __swig_setmethods__ = {}
    for _s in [base_cycle_metric_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, color_matrix_metric_header, name, value)
    __swig_getmethods__ = {}
    for _s in [base_cycle_metric_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, color_matrix_metric_header, name)
    __repr__ = _swig_repr

    def __init__(self, number_of_entries):
        this = _py_interop_metrics.new_color_matrix_metric_header(number_of_entries)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def number_of_entries(self):
        return _py_interop_metrics.color_matrix_metric_header_number_of_entries(self)
    if _newclass:
        default_header = staticmethod(_py_interop_metrics.color_matrix_metric_header_default_header)
    else:
        default_header = _py_interop_metrics.color_matrix_metric_header_default_header

    def clear(self):
        return _py_interop_metrics.color_matrix_metric_header_clear(self)
    __swig_destroy__ = _py_interop_metrics.delete_color_matrix_metric_header
    __del__ = lambda self: None
color_matrix_metric_header_swigregister = _py_interop_metrics.color_matrix_metric_header_swigregister
color_matrix_metric_header_swigregister(color_matrix_metric_header)

def color_matrix_metric_header_default_header():
    return _py_interop_metrics.color_matrix_metric_header_default_header()
color_matrix_metric_header_default_header = _py_interop_metrics.color_matrix_metric_header_default_header

class color_matrix_metric(base_cycle_metric):
    __swig_setmethods__ = {}
    for _s in [base_cycle_metric]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, color_matrix_metric, name, value)
    __swig_getmethods__ = {}
    for _s in [base_cycle_metric]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, color_matrix_metric, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.color_matrix_metric_TYPE
    LATEST_VERSION = _py_interop_metrics.color_matrix_metric_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_color_matrix_metric(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def color_matrix(self):
        return _py_interop_metrics.color_matrix_metric_color_matrix(self)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.color_matrix_metric_prefix)
    else:
        prefix = _py_interop_metrics.color_matrix_metric_prefix
    __swig_destroy__ = _py_interop_metrics.delete_color_matrix_metric
    __del__ = lambda self: None
color_matrix_metric_swigregister = _py_interop_metrics.color_matrix_metric_swigregister
color_matrix_metric_swigregister(color_matrix_metric)

def color_matrix_metric_prefix():
    return _py_interop_metrics.color_matrix_metric_prefix()
color_matrix_metric_prefix = _py_interop_metrics.color_matrix_metric_prefix

class distortion_metric_header(base_metric_header):
    __swig_setmethods__ = {}
    for _s in [base_metric_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, distortion_metric_header, name, value)
    __swig_getmethods__ = {}
    for _s in [base_metric_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, distortion_metric_header, name)
    __repr__ = _swig_repr

    def __init__(self, dimensions, channel_count, image_width, image_height, type):
        this = _py_interop_metrics.new_distortion_metric_header(dimensions, channel_count, image_width, image_height, type)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def channel_count(self):
        return _py_interop_metrics.distortion_metric_header_channel_count(self)

    def curve_count(self):
        return _py_interop_metrics.distortion_metric_header_curve_count(self)

    def coefficient_count(self, dim):
        return _py_interop_metrics.distortion_metric_header_coefficient_count(self, dim)

    def type(self):
        return _py_interop_metrics.distortion_metric_header_type(self)

    def image_width(self):
        return _py_interop_metrics.distortion_metric_header_image_width(self)

    def image_height(self):
        return _py_interop_metrics.distortion_metric_header_image_height(self)

    def total_number_of_coefficients(self):
        return _py_interop_metrics.distortion_metric_header_total_number_of_coefficients(self)

    def index(self, channel, curve, coeff):
        return _py_interop_metrics.distortion_metric_header_index(self, channel, curve, coeff)
    if _newclass:
        default_header = staticmethod(_py_interop_metrics.distortion_metric_header_default_header)
    else:
        default_header = _py_interop_metrics.distortion_metric_header_default_header

    def clear(self):
        return _py_interop_metrics.distortion_metric_header_clear(self)
    __swig_destroy__ = _py_interop_metrics.delete_distortion_metric_header
    __del__ = lambda self: None
distortion_metric_header_swigregister = _py_interop_metrics.distortion_metric_header_swigregister
distortion_metric_header_swigregister(distortion_metric_header)

def distortion_metric_header_default_header():
    return _py_interop_metrics.distortion_metric_header_default_header()
distortion_metric_header_default_header = _py_interop_metrics.distortion_metric_header_default_header

class distortion_metric(base_metric):
    __swig_setmethods__ = {}
    for _s in [base_metric]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, distortion_metric, name, value)
    __swig_getmethods__ = {}
    for _s in [base_metric]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, distortion_metric, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.distortion_metric_TYPE
    LATEST_VERSION = _py_interop_metrics.distortion_metric_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_distortion_metric(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def coefficients(self):
        return _py_interop_metrics.distortion_metric_coefficients(self)

    def coefficient_at(self, index):
        return _py_interop_metrics.distortion_metric_coefficient_at(self, index)

    def populate_coefficients_for(self, *args):
        return _py_interop_metrics.distortion_metric_populate_coefficients_for(self, *args)

    def absolute_distortion(self, header, channel, curve_index, image_width):
        return _py_interop_metrics.distortion_metric_absolute_distortion(self, header, channel, curve_index, image_width)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.distortion_metric_prefix)
    else:
        prefix = _py_interop_metrics.distortion_metric_prefix
    __swig_destroy__ = _py_interop_metrics.delete_distortion_metric
    __del__ = lambda self: None
distortion_metric_swigregister = _py_interop_metrics.distortion_metric_swigregister
distortion_metric_swigregister(distortion_metric)

def distortion_metric_prefix():
    return _py_interop_metrics.distortion_metric_prefix()
distortion_metric_prefix = _py_interop_metrics.distortion_metric_prefix

class dynamic_phasing_metric(base_read_metric):
    __swig_setmethods__ = {}
    for _s in [base_read_metric]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, dynamic_phasing_metric, name, value)
    __swig_getmethods__ = {}
    for _s in [base_read_metric]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, dynamic_phasing_metric, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.dynamic_phasing_metric_TYPE
    LATEST_VERSION = _py_interop_metrics.dynamic_phasing_metric_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_dynamic_phasing_metric(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def phasing_slope(self):
        return _py_interop_metrics.dynamic_phasing_metric_phasing_slope(self)

    def prephasing_slope(self):
        return _py_interop_metrics.dynamic_phasing_metric_prephasing_slope(self)

    def phasing_offset(self):
        return _py_interop_metrics.dynamic_phasing_metric_phasing_offset(self)

    def prephasing_offset(self):
        return _py_interop_metrics.dynamic_phasing_metric_prephasing_offset(self)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.dynamic_phasing_metric_prefix)
    else:
        prefix = _py_interop_metrics.dynamic_phasing_metric_prefix
    __swig_destroy__ = _py_interop_metrics.delete_dynamic_phasing_metric
    __del__ = lambda self: None
dynamic_phasing_metric_swigregister = _py_interop_metrics.dynamic_phasing_metric_swigregister
dynamic_phasing_metric_swigregister(dynamic_phasing_metric)

def dynamic_phasing_metric_prefix():
    return _py_interop_metrics.dynamic_phasing_metric_prefix()
dynamic_phasing_metric_prefix = _py_interop_metrics.dynamic_phasing_metric_prefix

class event_metric(base_event_metric):
    __swig_setmethods__ = {}
    for _s in [base_event_metric]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, event_metric, name, value)
    __swig_getmethods__ = {}
    for _s in [base_event_metric]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, event_metric, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.event_metric_TYPE
    LATEST_VERSION = _py_interop_metrics.event_metric_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_event_metric(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def set(self, *args):
        return _py_interop_metrics.event_metric_set(self, *args)

    def set_base(self, lane, tile):
        return _py_interop_metrics.event_metric_set_base(self, lane, tile)
    if _newclass:
        create_id = staticmethod(_py_interop_metrics.event_metric_create_id)
    else:
        create_id = _py_interop_metrics.event_metric_create_id
    if _newclass:
        event_from_id = staticmethod(_py_interop_metrics.event_metric_event_from_id)
    else:
        event_from_id = _py_interop_metrics.event_metric_event_from_id

    def date_time(self):
        return _py_interop_metrics.event_metric_date_time(self)

    def point_ticks(self):
        return _py_interop_metrics.event_metric_point_ticks(self)

    def date_time_csharp(self):
        return _py_interop_metrics.event_metric_date_time_csharp(self)

    def event_value(self):
        return _py_interop_metrics.event_metric_event_value(self)

    def elapsed_ms(self):
        return _py_interop_metrics.event_metric_elapsed_ms(self)

    def elapsed_ticks(self):
        return _py_interop_metrics.event_metric_elapsed_ticks(self)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.event_metric_prefix)
    else:
        prefix = _py_interop_metrics.event_metric_prefix
    __swig_destroy__ = _py_interop_metrics.delete_event_metric
    __del__ = lambda self: None
event_metric_swigregister = _py_interop_metrics.event_metric_swigregister
event_metric_swigregister(event_metric)

def event_metric_create_id(lane, tile, cycle, event_type=0):
    return _py_interop_metrics.event_metric_create_id(lane, tile, cycle, event_type)
event_metric_create_id = _py_interop_metrics.event_metric_create_id

def event_metric_event_from_id(id):
    return _py_interop_metrics.event_metric_event_from_id(id)
event_metric_event_from_id = _py_interop_metrics.event_metric_event_from_id

def event_metric_prefix():
    return _py_interop_metrics.event_metric_prefix()
event_metric_prefix = _py_interop_metrics.event_metric_prefix

class extended_tile_metric(base_metric):
    __swig_setmethods__ = {}
    for _s in [base_metric]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, extended_tile_metric, name, value)
    __swig_getmethods__ = {}
    for _s in [base_metric]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, extended_tile_metric, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.extended_tile_metric_TYPE
    LATEST_VERSION = _py_interop_metrics.extended_tile_metric_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_extended_tile_metric(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def set(self, *args):
        return _py_interop_metrics.extended_tile_metric_set(self, *args)

    def cluster_count_occupied(self):
        return _py_interop_metrics.extended_tile_metric_cluster_count_occupied(self)

    def cluster_count_occupied_k(self):
        return _py_interop_metrics.extended_tile_metric_cluster_count_occupied_k(self)

    def percent_occupied(self, cluster_count_k):
        return _py_interop_metrics.extended_tile_metric_percent_occupied(self, cluster_count_k)

    def percent_occupied_lookup(self, tile_metrics):
        return _py_interop_metrics.extended_tile_metric_percent_occupied_lookup(self, tile_metrics)

    def upper_left(self):
        return _py_interop_metrics.extended_tile_metric_upper_left(self)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.extended_tile_metric_prefix)
    else:
        prefix = _py_interop_metrics.extended_tile_metric_prefix
    __swig_destroy__ = _py_interop_metrics.delete_extended_tile_metric
    __del__ = lambda self: None
extended_tile_metric_swigregister = _py_interop_metrics.extended_tile_metric_swigregister
extended_tile_metric_swigregister(extended_tile_metric)

def extended_tile_metric_prefix():
    return _py_interop_metrics.extended_tile_metric_prefix()
extended_tile_metric_prefix = _py_interop_metrics.extended_tile_metric_prefix

class fwhm_grid_metric_header(base_cycle_metric_header):
    __swig_setmethods__ = {}
    for _s in [base_cycle_metric_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, fwhm_grid_metric_header, name, value)
    __swig_getmethods__ = {}
    for _s in [base_cycle_metric_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, fwhm_grid_metric_header, name)
    __repr__ = _swig_repr

    def __init__(self, num_bins_x, num_bins_y, channel_count):
        this = _py_interop_metrics.new_fwhm_grid_metric_header(num_bins_x, num_bins_y, channel_count)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def num_bins_x(self):
        return _py_interop_metrics.fwhm_grid_metric_header_num_bins_x(self)

    def num_bins_y(self):
        return _py_interop_metrics.fwhm_grid_metric_header_num_bins_y(self)

    def channel_count(self):
        return _py_interop_metrics.fwhm_grid_metric_header_channel_count(self)
    if _newclass:
        default_header = staticmethod(_py_interop_metrics.fwhm_grid_metric_header_default_header)
    else:
        default_header = _py_interop_metrics.fwhm_grid_metric_header_default_header

    def clear(self):
        return _py_interop_metrics.fwhm_grid_metric_header_clear(self)
    __swig_destroy__ = _py_interop_metrics.delete_fwhm_grid_metric_header
    __del__ = lambda self: None
fwhm_grid_metric_header_swigregister = _py_interop_metrics.fwhm_grid_metric_header_swigregister
fwhm_grid_metric_header_swigregister(fwhm_grid_metric_header)

def fwhm_grid_metric_header_default_header():
    return _py_interop_metrics.fwhm_grid_metric_header_default_header()
fwhm_grid_metric_header_default_header = _py_interop_metrics.fwhm_grid_metric_header_default_header

class fwhm_grid_metric(base_cycle_metric):
    __swig_setmethods__ = {}
    for _s in [base_cycle_metric]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, fwhm_grid_metric, name, value)
    __swig_getmethods__ = {}
    for _s in [base_cycle_metric]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, fwhm_grid_metric, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.fwhm_grid_metric_TYPE
    LATEST_VERSION = _py_interop_metrics.fwhm_grid_metric_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_fwhm_grid_metric(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def focus_score(self, channel, row_bin, col_bin):
        return _py_interop_metrics.fwhm_grid_metric_focus_score(self, channel, row_bin, col_bin)

    def channel_count(self):
        return _py_interop_metrics.fwhm_grid_metric_channel_count(self)

    def num_bins_row(self):
        return _py_interop_metrics.fwhm_grid_metric_num_bins_row(self)

    def num_bins_col(self):
        return _py_interop_metrics.fwhm_grid_metric_num_bins_col(self)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.fwhm_grid_metric_prefix)
    else:
        prefix = _py_interop_metrics.fwhm_grid_metric_prefix
    __swig_destroy__ = _py_interop_metrics.delete_fwhm_grid_metric
    __del__ = lambda self: None
fwhm_grid_metric_swigregister = _py_interop_metrics.fwhm_grid_metric_swigregister
fwhm_grid_metric_swigregister(fwhm_grid_metric)

def fwhm_grid_metric_prefix():
    return _py_interop_metrics.fwhm_grid_metric_prefix()
fwhm_grid_metric_prefix = _py_interop_metrics.fwhm_grid_metric_prefix

class pf_grid_metric_header(base_metric_header):
    __swig_setmethods__ = {}
    for _s in [base_metric_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, pf_grid_metric_header, name, value)
    __swig_getmethods__ = {}
    for _s in [base_metric_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, pf_grid_metric_header, name)
    __repr__ = _swig_repr

    def __init__(self, num_bins_x, num_bins_y, subtile_area_in_mm2):
        this = _py_interop_metrics.new_pf_grid_metric_header(num_bins_x, num_bins_y, subtile_area_in_mm2)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def num_bins_x(self):
        return _py_interop_metrics.pf_grid_metric_header_num_bins_x(self)

    def num_bins_y(self):
        return _py_interop_metrics.pf_grid_metric_header_num_bins_y(self)

    def subtile_area_in_mm2(self):
        return _py_interop_metrics.pf_grid_metric_header_subtile_area_in_mm2(self)
    if _newclass:
        default_header = staticmethod(_py_interop_metrics.pf_grid_metric_header_default_header)
    else:
        default_header = _py_interop_metrics.pf_grid_metric_header_default_header

    def clear(self):
        return _py_interop_metrics.pf_grid_metric_header_clear(self)
    __swig_destroy__ = _py_interop_metrics.delete_pf_grid_metric_header
    __del__ = lambda self: None
pf_grid_metric_header_swigregister = _py_interop_metrics.pf_grid_metric_header_swigregister
pf_grid_metric_header_swigregister(pf_grid_metric_header)

def pf_grid_metric_header_default_header():
    return _py_interop_metrics.pf_grid_metric_header_default_header()
pf_grid_metric_header_default_header = _py_interop_metrics.pf_grid_metric_header_default_header

class pf_grid_metric(base_metric):
    __swig_setmethods__ = {}
    for _s in [base_metric]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, pf_grid_metric, name, value)
    __swig_getmethods__ = {}
    for _s in [base_metric]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, pf_grid_metric, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.pf_grid_metric_TYPE
    LATEST_VERSION = _py_interop_metrics.pf_grid_metric_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_pf_grid_metric(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def raw_cluster_count(self, x_bin, y_bin):
        return _py_interop_metrics.pf_grid_metric_raw_cluster_count(self, x_bin, y_bin)

    def pf_cluster_count(self, x_bin, y_bin):
        return _py_interop_metrics.pf_grid_metric_pf_cluster_count(self, x_bin, y_bin)

    def raw_cluster_density_k(self, x_bin, y_bin, density):
        return _py_interop_metrics.pf_grid_metric_raw_cluster_density_k(self, x_bin, y_bin, density)

    def pf_cluster_density_k(self, x_bin, y_bin, density):
        return _py_interop_metrics.pf_grid_metric_pf_cluster_density_k(self, x_bin, y_bin, density)

    def percent_pf(self, x_bin, y_bin):
        return _py_interop_metrics.pf_grid_metric_percent_pf(self, x_bin, y_bin)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.pf_grid_metric_prefix)
    else:
        prefix = _py_interop_metrics.pf_grid_metric_prefix
    __swig_destroy__ = _py_interop_metrics.delete_pf_grid_metric
    __del__ = lambda self: None
pf_grid_metric_swigregister = _py_interop_metrics.pf_grid_metric_swigregister
pf_grid_metric_swigregister(pf_grid_metric)

def pf_grid_metric_prefix():
    return _py_interop_metrics.pf_grid_metric_prefix()
pf_grid_metric_prefix = _py_interop_metrics.pf_grid_metric_prefix

class phasing_metric(base_cycle_metric):
    __swig_setmethods__ = {}
    for _s in [base_cycle_metric]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, phasing_metric, name, value)
    __swig_getmethods__ = {}
    for _s in [base_cycle_metric]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, phasing_metric, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.phasing_metric_TYPE
    LATEST_VERSION = _py_interop_metrics.phasing_metric_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_phasing_metric(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def phasing_weight(self):
        return _py_interop_metrics.phasing_metric_phasing_weight(self)

    def prephasing_weight(self):
        return _py_interop_metrics.phasing_metric_prephasing_weight(self)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.phasing_metric_prefix)
    else:
        prefix = _py_interop_metrics.phasing_metric_prefix
    __swig_destroy__ = _py_interop_metrics.delete_phasing_metric
    __del__ = lambda self: None
phasing_metric_swigregister = _py_interop_metrics.phasing_metric_swigregister
phasing_metric_swigregister(phasing_metric)

def phasing_metric_prefix():
    return _py_interop_metrics.phasing_metric_prefix()
phasing_metric_prefix = _py_interop_metrics.phasing_metric_prefix

class q_grid_metric_header(base_metric_header):
    __swig_setmethods__ = {}
    for _s in [base_metric_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, q_grid_metric_header, name, value)
    __swig_getmethods__ = {}
    for _s in [base_metric_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, q_grid_metric_header, name)
    __repr__ = _swig_repr

    def __init__(self, num_bins_x, num_bins_y):
        this = _py_interop_metrics.new_q_grid_metric_header(num_bins_x, num_bins_y)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def num_bins_x(self):
        return _py_interop_metrics.q_grid_metric_header_num_bins_x(self)

    def num_bins_y(self):
        return _py_interop_metrics.q_grid_metric_header_num_bins_y(self)
    if _newclass:
        default_header = staticmethod(_py_interop_metrics.q_grid_metric_header_default_header)
    else:
        default_header = _py_interop_metrics.q_grid_metric_header_default_header

    def clear(self):
        return _py_interop_metrics.q_grid_metric_header_clear(self)
    __swig_destroy__ = _py_interop_metrics.delete_q_grid_metric_header
    __del__ = lambda self: None
q_grid_metric_header_swigregister = _py_interop_metrics.q_grid_metric_header_swigregister
q_grid_metric_header_swigregister(q_grid_metric_header)

def q_grid_metric_header_default_header():
    return _py_interop_metrics.q_grid_metric_header_default_header()
q_grid_metric_header_default_header = _py_interop_metrics.q_grid_metric_header_default_header

class q_grid_metric(base_read_metric):
    __swig_setmethods__ = {}
    for _s in [base_read_metric]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, q_grid_metric, name, value)
    __swig_getmethods__ = {}
    for _s in [base_read_metric]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, q_grid_metric, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.q_grid_metric_TYPE
    LATEST_VERSION = _py_interop_metrics.q_grid_metric_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_q_grid_metric(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def raw_cluster_count(self, x_bin, y_bin):
        return _py_interop_metrics.q_grid_metric_raw_cluster_count(self, x_bin, y_bin)

    def q30_cluster_count(self, x_bin, y_bin):
        return _py_interop_metrics.q_grid_metric_q30_cluster_count(self, x_bin, y_bin)

    def percent_q30(self, x_bin, y_bin):
        return _py_interop_metrics.q_grid_metric_percent_q30(self, x_bin, y_bin)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.q_grid_metric_prefix)
    else:
        prefix = _py_interop_metrics.q_grid_metric_prefix
    __swig_destroy__ = _py_interop_metrics.delete_q_grid_metric
    __del__ = lambda self: None
q_grid_metric_swigregister = _py_interop_metrics.q_grid_metric_swigregister
q_grid_metric_swigregister(q_grid_metric)

def q_grid_metric_prefix():
    return _py_interop_metrics.q_grid_metric_prefix()
q_grid_metric_prefix = _py_interop_metrics.q_grid_metric_prefix

class registration_metric_header(base_cycle_metric_header):
    __swig_setmethods__ = {}
    for _s in [base_cycle_metric_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, registration_metric_header, name, value)
    __swig_getmethods__ = {}
    for _s in [base_cycle_metric_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, registration_metric_header, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _py_interop_metrics.new_registration_metric_header(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def channel_count(self):
        return _py_interop_metrics.registration_metric_header_channel_count(self)

    def region_count(self):
        return _py_interop_metrics.registration_metric_header_region_count(self)

    def fiducial_locations(self):
        return _py_interop_metrics.registration_metric_header_fiducial_locations(self)

    def fiducial_layout(self):
        return _py_interop_metrics.registration_metric_header_fiducial_layout(self)
    if _newclass:
        default_header = staticmethod(_py_interop_metrics.registration_metric_header_default_header)
    else:
        default_header = _py_interop_metrics.registration_metric_header_default_header

    def clear(self):
        return _py_interop_metrics.registration_metric_header_clear(self)
    __swig_destroy__ = _py_interop_metrics.delete_registration_metric_header
    __del__ = lambda self: None
registration_metric_header_swigregister = _py_interop_metrics.registration_metric_header_swigregister
registration_metric_header_swigregister(registration_metric_header)

def registration_metric_header_default_header():
    return _py_interop_metrics.registration_metric_header_default_header()
registration_metric_header_default_header = _py_interop_metrics.registration_metric_header_default_header

class registration_metric(base_cycle_metric):
    __swig_setmethods__ = {}
    for _s in [base_cycle_metric]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, registration_metric, name, value)
    __swig_getmethods__ = {}
    for _s in [base_cycle_metric]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, registration_metric, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.registration_metric_TYPE
    LATEST_VERSION = _py_interop_metrics.registration_metric_LATEST_VERSION
    AFFINE_LENGTH = _py_interop_metrics.registration_metric_AFFINE_LENGTH
    SUBREGION_PARAM_LENGTH = _py_interop_metrics.registration_metric_SUBREGION_PARAM_LENGTH

    def __init__(self, *args):
        this = _py_interop_metrics.new_registration_metric(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def affine_transform(self, *args):
        return _py_interop_metrics.registration_metric_affine_transform(self, *args)

    def predicted_error(self):
        return _py_interop_metrics.registration_metric_predicted_error(self)

    def sub_tile_offsets(self, *args):
        return _py_interop_metrics.registration_metric_sub_tile_offsets(self, *args)

    def channel_count(self):
        return _py_interop_metrics.registration_metric_channel_count(self)

    def sub_region_count(self):
        return _py_interop_metrics.registration_metric_sub_region_count(self)

    def set_predicted_error(self, index, err):
        return _py_interop_metrics.registration_metric_set_predicted_error(self, index, err)

    def max_residual_radial_errors(self):
        return _py_interop_metrics.registration_metric_max_residual_radial_errors(self)

    def max_residual_radial_error(self, *args):
        return _py_interop_metrics.registration_metric_max_residual_radial_error(self, *args)

    def max_residual_x_error(self, channel):
        return _py_interop_metrics.registration_metric_max_residual_x_error(self, channel)

    def max_residual_y_error(self, channel):
        return _py_interop_metrics.registration_metric_max_residual_y_error(self, channel)

    def shear(self, channel):
        return _py_interop_metrics.registration_metric_shear(self, channel)

    def theta_z(self, channel):
        return _py_interop_metrics.registration_metric_theta_z(self, channel)

    def theta(self, channel):
        return _py_interop_metrics.registration_metric_theta(self, channel)

    def set_rotation(self, channel, theta, shear, theta_z):
        return _py_interop_metrics.registration_metric_set_rotation(self, channel, theta, shear, theta_z)

    def is_any_channel_registration_failure(self):
        return _py_interop_metrics.registration_metric_is_any_channel_registration_failure(self)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.registration_metric_prefix)
    else:
        prefix = _py_interop_metrics.registration_metric_prefix
    __swig_destroy__ = _py_interop_metrics.delete_registration_metric
    __del__ = lambda self: None
registration_metric_swigregister = _py_interop_metrics.registration_metric_swigregister
registration_metric_swigregister(registration_metric)

def registration_metric_prefix():
    return _py_interop_metrics.registration_metric_prefix()
registration_metric_prefix = _py_interop_metrics.registration_metric_prefix

class run_diagnostics_metric(base_cycle_metric):
    __swig_setmethods__ = {}
    for _s in [base_cycle_metric]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, run_diagnostics_metric, name, value)
    __swig_getmethods__ = {}
    for _s in [base_cycle_metric]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, run_diagnostics_metric, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.run_diagnostics_metric_TYPE
    LATEST_VERSION = _py_interop_metrics.run_diagnostics_metric_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_run_diagnostics_metric(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def blank_image(self, flag):
        return _py_interop_metrics.run_diagnostics_metric_blank_image(self, flag)

    def dead_tile(self, flag):
        return _py_interop_metrics.run_diagnostics_metric_dead_tile(self, flag)

    def failed_tile_cycle(self, flag):
        return _py_interop_metrics.run_diagnostics_metric_failed_tile_cycle(self, flag)

    def q_outlier(self, flag):
        return _py_interop_metrics.run_diagnostics_metric_q_outlier(self, flag)

    def get_issues_for_entry(self):
        return _py_interop_metrics.run_diagnostics_metric_get_issues_for_entry(self)

    def get_issue(self, type_index):
        return _py_interop_metrics.run_diagnostics_metric_get_issue(self, type_index)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.run_diagnostics_metric_prefix)
    else:
        prefix = _py_interop_metrics.run_diagnostics_metric_prefix
    __swig_destroy__ = _py_interop_metrics.delete_run_diagnostics_metric
    __del__ = lambda self: None
run_diagnostics_metric_swigregister = _py_interop_metrics.run_diagnostics_metric_swigregister
run_diagnostics_metric_swigregister(run_diagnostics_metric)

def run_diagnostics_metric_prefix():
    return _py_interop_metrics.run_diagnostics_metric_prefix()
run_diagnostics_metric_prefix = _py_interop_metrics.run_diagnostics_metric_prefix

class static_run_metric_header(base_static_run_metric_header):
    __swig_setmethods__ = {}
    for _s in [base_static_run_metric_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, static_run_metric_header, name, value)
    __swig_getmethods__ = {}
    for _s in [base_static_run_metric_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, static_run_metric_header, name)
    __repr__ = _swig_repr

    def __init__(self, curve_length, curve_check):
        this = _py_interop_metrics.new_static_run_metric_header(curve_length, curve_check)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def curve_length(self):
        return _py_interop_metrics.static_run_metric_header_curve_length(self)

    def curve_check(self):
        return _py_interop_metrics.static_run_metric_header_curve_check(self)
    if _newclass:
        default_header = staticmethod(_py_interop_metrics.static_run_metric_header_default_header)
    else:
        default_header = _py_interop_metrics.static_run_metric_header_default_header

    def clear(self):
        return _py_interop_metrics.static_run_metric_header_clear(self)
    __swig_destroy__ = _py_interop_metrics.delete_static_run_metric_header
    __del__ = lambda self: None
static_run_metric_header_swigregister = _py_interop_metrics.static_run_metric_header_swigregister
static_run_metric_header_swigregister(static_run_metric_header)

def static_run_metric_header_default_header():
    return _py_interop_metrics.static_run_metric_header_default_header()
static_run_metric_header_default_header = _py_interop_metrics.static_run_metric_header_default_header

class static_run_metric(base_static_run_metric):
    __swig_setmethods__ = {}
    for _s in [base_static_run_metric]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, static_run_metric, name, value)
    __swig_getmethods__ = {}
    for _s in [base_static_run_metric]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, static_run_metric, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.static_run_metric_TYPE
    LATEST_VERSION = _py_interop_metrics.static_run_metric_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_static_run_metric(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def x_values(self, curve_length):
        return _py_interop_metrics.static_run_metric_x_values(self, curve_length)

    def y_values(self, curve_check):
        return _py_interop_metrics.static_run_metric_y_values(self, curve_check)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.static_run_metric_prefix)
    else:
        prefix = _py_interop_metrics.static_run_metric_prefix
    __swig_destroy__ = _py_interop_metrics.delete_static_run_metric
    __del__ = lambda self: None
static_run_metric_swigregister = _py_interop_metrics.static_run_metric_swigregister
static_run_metric_swigregister(static_run_metric)

def static_run_metric_prefix():
    return _py_interop_metrics.static_run_metric_prefix()
static_run_metric_prefix = _py_interop_metrics.static_run_metric_prefix

class base_alignment_metrics(base_cycle_metric_header):
    __swig_setmethods__ = {}
    for _s in [base_cycle_metric_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, base_alignment_metrics, name, value)
    __swig_getmethods__ = {}
    for _s in [base_cycle_metric_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, base_alignment_metrics, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.base_alignment_metrics_TYPE
    LATEST_VERSION = _py_interop_metrics.base_alignment_metrics_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_base_alignment_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def data_source_exists(self, *args):
        return _py_interop_metrics.base_alignment_metrics_data_source_exists(self, *args)

    def rebuild_index(self, update_ids=False):
        return _py_interop_metrics.base_alignment_metrics_rebuild_index(self, update_ids)

    def resize(self, n):
        return _py_interop_metrics.base_alignment_metrics_resize(self, n)

    def reserve(self, n):
        return _py_interop_metrics.base_alignment_metrics_reserve(self, n)

    def trim(self, n):
        return _py_interop_metrics.base_alignment_metrics_trim(self, n)

    def find(self, *args):
        return _py_interop_metrics.base_alignment_metrics_find(self, *args)

    def has_metric(self, *args):
        return _py_interop_metrics.base_alignment_metrics_has_metric(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.base_alignment_metrics_insert(self, *args)

    def get_metric(self, *args):
        return _py_interop_metrics.base_alignment_metrics_get_metric(self, *args)

    def at(self, n):
        return _py_interop_metrics.base_alignment_metrics_at(self, n)

    def set_version(self, version):
        return _py_interop_metrics.base_alignment_metrics_set_version(self, version)

    def keys(self):
        return _py_interop_metrics.base_alignment_metrics_keys(self)

    def lanes(self):
        return _py_interop_metrics.base_alignment_metrics_lanes(self)

    def lane_count(self):
        return _py_interop_metrics.base_alignment_metrics_lane_count(self)

    def max_lane(self):
        return _py_interop_metrics.base_alignment_metrics_max_lane(self)

    def tile_numbers_for_lane(self, lane):
        return _py_interop_metrics.base_alignment_metrics_tile_numbers_for_lane(self, lane)

    def tile_numbers(self):
        return _py_interop_metrics.base_alignment_metrics_tile_numbers(self)

    def metrics_for_lane(self, *args):
        return _py_interop_metrics.base_alignment_metrics_metrics_for_lane(self, *args)

    def cycles(self):
        return _py_interop_metrics.base_alignment_metrics_cycles(self)

    def metrics_for_cycle(self, cycle):
        return _py_interop_metrics.base_alignment_metrics_metrics_for_cycle(self, cycle)

    def size(self):
        return _py_interop_metrics.base_alignment_metrics_size(self)

    def empty(self):
        return _py_interop_metrics.base_alignment_metrics_empty(self)

    def version(self):
        return _py_interop_metrics.base_alignment_metrics_version(self)

    def clear(self):
        return _py_interop_metrics.base_alignment_metrics_clear(self)

    def metrics(self):
        return _py_interop_metrics.base_alignment_metrics_metrics(self)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.base_alignment_metrics_prefix)
    else:
        prefix = _py_interop_metrics.base_alignment_metrics_prefix
    if _newclass:
        suffix = staticmethod(_py_interop_metrics.base_alignment_metrics_suffix)
    else:
        suffix = _py_interop_metrics.base_alignment_metrics_suffix

    def get_metric_ref(self, *args):
        return _py_interop_metrics.base_alignment_metrics_get_metric_ref(self, *args)
    __swig_destroy__ = _py_interop_metrics.delete_base_alignment_metrics
    __del__ = lambda self: None
base_alignment_metrics_swigregister = _py_interop_metrics.base_alignment_metrics_swigregister
base_alignment_metrics_swigregister(base_alignment_metrics)

def base_alignment_metrics_prefix():
    return _py_interop_metrics.base_alignment_metrics_prefix()
base_alignment_metrics_prefix = _py_interop_metrics.base_alignment_metrics_prefix

def base_alignment_metrics_suffix():
    return _py_interop_metrics.base_alignment_metrics_suffix()
base_alignment_metrics_suffix = _py_interop_metrics.base_alignment_metrics_suffix

class vector_alignment_metrics(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_alignment_metrics, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_alignment_metrics, name)
    __repr__ = _swig_repr
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _py_interop_metrics.vector_alignment_metrics___nonzero__(self)

    def __bool__(self):
        return _py_interop_metrics.vector_alignment_metrics___bool__(self)

    def __len__(self):
        return _py_interop_metrics.vector_alignment_metrics___len__(self)

    def __getslice__(self, i, j):
        return _py_interop_metrics.vector_alignment_metrics___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _py_interop_metrics.vector_alignment_metrics___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _py_interop_metrics.vector_alignment_metrics___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _py_interop_metrics.vector_alignment_metrics___delitem__(self, *args)

    def __getitem__(self, *args):
        return _py_interop_metrics.vector_alignment_metrics___getitem__(self, *args)

    def __setitem__(self, *args):
        return _py_interop_metrics.vector_alignment_metrics___setitem__(self, *args)

    def pop(self):
        return _py_interop_metrics.vector_alignment_metrics_pop(self)

    def append(self, x):
        return _py_interop_metrics.vector_alignment_metrics_append(self, x)

    def empty(self):
        return _py_interop_metrics.vector_alignment_metrics_empty(self)

    def size(self):
        return _py_interop_metrics.vector_alignment_metrics_size(self)

    def swap(self, v):
        return _py_interop_metrics.vector_alignment_metrics_swap(self, v)

    def rbegin(self):
        return _py_interop_metrics.vector_alignment_metrics_rbegin(self)

    def rend(self):
        return _py_interop_metrics.vector_alignment_metrics_rend(self)

    def clear(self):
        return _py_interop_metrics.vector_alignment_metrics_clear(self)

    def get_allocator(self):
        return _py_interop_metrics.vector_alignment_metrics_get_allocator(self)

    def pop_back(self):
        return _py_interop_metrics.vector_alignment_metrics_pop_back(self)

    def erase(self, *args):
        return _py_interop_metrics.vector_alignment_metrics_erase(self, *args)

    def __init__(self, *args):
        this = _py_interop_metrics.new_vector_alignment_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _py_interop_metrics.vector_alignment_metrics_push_back(self, x)

    def front(self):
        return _py_interop_metrics.vector_alignment_metrics_front(self)

    def back(self):
        return _py_interop_metrics.vector_alignment_metrics_back(self)

    def assign(self, n, x):
        return _py_interop_metrics.vector_alignment_metrics_assign(self, n, x)

    def resize(self, *args):
        return _py_interop_metrics.vector_alignment_metrics_resize(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.vector_alignment_metrics_insert(self, *args)

    def reserve(self, n):
        return _py_interop_metrics.vector_alignment_metrics_reserve(self, n)

    def capacity(self):
        return _py_interop_metrics.vector_alignment_metrics_capacity(self)
    __swig_destroy__ = _py_interop_metrics.delete_vector_alignment_metrics
    __del__ = lambda self: None
vector_alignment_metrics_swigregister = _py_interop_metrics.vector_alignment_metrics_swigregister
vector_alignment_metrics_swigregister(vector_alignment_metrics)

class base_basecalling_metrics(basecalling_metric_header):
    __swig_setmethods__ = {}
    for _s in [basecalling_metric_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, base_basecalling_metrics, name, value)
    __swig_getmethods__ = {}
    for _s in [basecalling_metric_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, base_basecalling_metrics, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.base_basecalling_metrics_TYPE
    LATEST_VERSION = _py_interop_metrics.base_basecalling_metrics_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_base_basecalling_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def data_source_exists(self, *args):
        return _py_interop_metrics.base_basecalling_metrics_data_source_exists(self, *args)

    def rebuild_index(self, update_ids=False):
        return _py_interop_metrics.base_basecalling_metrics_rebuild_index(self, update_ids)

    def resize(self, n):
        return _py_interop_metrics.base_basecalling_metrics_resize(self, n)

    def reserve(self, n):
        return _py_interop_metrics.base_basecalling_metrics_reserve(self, n)

    def trim(self, n):
        return _py_interop_metrics.base_basecalling_metrics_trim(self, n)

    def find(self, *args):
        return _py_interop_metrics.base_basecalling_metrics_find(self, *args)

    def has_metric(self, *args):
        return _py_interop_metrics.base_basecalling_metrics_has_metric(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.base_basecalling_metrics_insert(self, *args)

    def get_metric(self, *args):
        return _py_interop_metrics.base_basecalling_metrics_get_metric(self, *args)

    def at(self, n):
        return _py_interop_metrics.base_basecalling_metrics_at(self, n)

    def set_version(self, version):
        return _py_interop_metrics.base_basecalling_metrics_set_version(self, version)

    def keys(self):
        return _py_interop_metrics.base_basecalling_metrics_keys(self)

    def lanes(self):
        return _py_interop_metrics.base_basecalling_metrics_lanes(self)

    def lane_count(self):
        return _py_interop_metrics.base_basecalling_metrics_lane_count(self)

    def max_lane(self):
        return _py_interop_metrics.base_basecalling_metrics_max_lane(self)

    def tile_numbers_for_lane(self, lane):
        return _py_interop_metrics.base_basecalling_metrics_tile_numbers_for_lane(self, lane)

    def tile_numbers(self):
        return _py_interop_metrics.base_basecalling_metrics_tile_numbers(self)

    def metrics_for_lane(self, *args):
        return _py_interop_metrics.base_basecalling_metrics_metrics_for_lane(self, *args)

    def cycles(self):
        return _py_interop_metrics.base_basecalling_metrics_cycles(self)

    def metrics_for_cycle(self, cycle):
        return _py_interop_metrics.base_basecalling_metrics_metrics_for_cycle(self, cycle)

    def size(self):
        return _py_interop_metrics.base_basecalling_metrics_size(self)

    def empty(self):
        return _py_interop_metrics.base_basecalling_metrics_empty(self)

    def version(self):
        return _py_interop_metrics.base_basecalling_metrics_version(self)

    def clear(self):
        return _py_interop_metrics.base_basecalling_metrics_clear(self)

    def metrics(self):
        return _py_interop_metrics.base_basecalling_metrics_metrics(self)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.base_basecalling_metrics_prefix)
    else:
        prefix = _py_interop_metrics.base_basecalling_metrics_prefix
    if _newclass:
        suffix = staticmethod(_py_interop_metrics.base_basecalling_metrics_suffix)
    else:
        suffix = _py_interop_metrics.base_basecalling_metrics_suffix

    def get_metric_ref(self, *args):
        return _py_interop_metrics.base_basecalling_metrics_get_metric_ref(self, *args)
    __swig_destroy__ = _py_interop_metrics.delete_base_basecalling_metrics
    __del__ = lambda self: None
base_basecalling_metrics_swigregister = _py_interop_metrics.base_basecalling_metrics_swigregister
base_basecalling_metrics_swigregister(base_basecalling_metrics)

def base_basecalling_metrics_prefix():
    return _py_interop_metrics.base_basecalling_metrics_prefix()
base_basecalling_metrics_prefix = _py_interop_metrics.base_basecalling_metrics_prefix

def base_basecalling_metrics_suffix():
    return _py_interop_metrics.base_basecalling_metrics_suffix()
base_basecalling_metrics_suffix = _py_interop_metrics.base_basecalling_metrics_suffix

class vector_basecalling_metrics(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_basecalling_metrics, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_basecalling_metrics, name)
    __repr__ = _swig_repr
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _py_interop_metrics.vector_basecalling_metrics___nonzero__(self)

    def __bool__(self):
        return _py_interop_metrics.vector_basecalling_metrics___bool__(self)

    def __len__(self):
        return _py_interop_metrics.vector_basecalling_metrics___len__(self)

    def __getslice__(self, i, j):
        return _py_interop_metrics.vector_basecalling_metrics___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _py_interop_metrics.vector_basecalling_metrics___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _py_interop_metrics.vector_basecalling_metrics___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _py_interop_metrics.vector_basecalling_metrics___delitem__(self, *args)

    def __getitem__(self, *args):
        return _py_interop_metrics.vector_basecalling_metrics___getitem__(self, *args)

    def __setitem__(self, *args):
        return _py_interop_metrics.vector_basecalling_metrics___setitem__(self, *args)

    def pop(self):
        return _py_interop_metrics.vector_basecalling_metrics_pop(self)

    def append(self, x):
        return _py_interop_metrics.vector_basecalling_metrics_append(self, x)

    def empty(self):
        return _py_interop_metrics.vector_basecalling_metrics_empty(self)

    def size(self):
        return _py_interop_metrics.vector_basecalling_metrics_size(self)

    def swap(self, v):
        return _py_interop_metrics.vector_basecalling_metrics_swap(self, v)

    def rbegin(self):
        return _py_interop_metrics.vector_basecalling_metrics_rbegin(self)

    def rend(self):
        return _py_interop_metrics.vector_basecalling_metrics_rend(self)

    def clear(self):
        return _py_interop_metrics.vector_basecalling_metrics_clear(self)

    def get_allocator(self):
        return _py_interop_metrics.vector_basecalling_metrics_get_allocator(self)

    def pop_back(self):
        return _py_interop_metrics.vector_basecalling_metrics_pop_back(self)

    def erase(self, *args):
        return _py_interop_metrics.vector_basecalling_metrics_erase(self, *args)

    def __init__(self, *args):
        this = _py_interop_metrics.new_vector_basecalling_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _py_interop_metrics.vector_basecalling_metrics_push_back(self, x)

    def front(self):
        return _py_interop_metrics.vector_basecalling_metrics_front(self)

    def back(self):
        return _py_interop_metrics.vector_basecalling_metrics_back(self)

    def assign(self, n, x):
        return _py_interop_metrics.vector_basecalling_metrics_assign(self, n, x)

    def resize(self, *args):
        return _py_interop_metrics.vector_basecalling_metrics_resize(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.vector_basecalling_metrics_insert(self, *args)

    def reserve(self, n):
        return _py_interop_metrics.vector_basecalling_metrics_reserve(self, n)

    def capacity(self):
        return _py_interop_metrics.vector_basecalling_metrics_capacity(self)
    __swig_destroy__ = _py_interop_metrics.delete_vector_basecalling_metrics
    __del__ = lambda self: None
vector_basecalling_metrics_swigregister = _py_interop_metrics.vector_basecalling_metrics_swigregister
vector_basecalling_metrics_swigregister(vector_basecalling_metrics)

class base_color_matrix_metrics(color_matrix_metric_header):
    __swig_setmethods__ = {}
    for _s in [color_matrix_metric_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, base_color_matrix_metrics, name, value)
    __swig_getmethods__ = {}
    for _s in [color_matrix_metric_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, base_color_matrix_metrics, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.base_color_matrix_metrics_TYPE
    LATEST_VERSION = _py_interop_metrics.base_color_matrix_metrics_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_base_color_matrix_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def data_source_exists(self, *args):
        return _py_interop_metrics.base_color_matrix_metrics_data_source_exists(self, *args)

    def rebuild_index(self, update_ids=False):
        return _py_interop_metrics.base_color_matrix_metrics_rebuild_index(self, update_ids)

    def resize(self, n):
        return _py_interop_metrics.base_color_matrix_metrics_resize(self, n)

    def reserve(self, n):
        return _py_interop_metrics.base_color_matrix_metrics_reserve(self, n)

    def trim(self, n):
        return _py_interop_metrics.base_color_matrix_metrics_trim(self, n)

    def find(self, *args):
        return _py_interop_metrics.base_color_matrix_metrics_find(self, *args)

    def has_metric(self, *args):
        return _py_interop_metrics.base_color_matrix_metrics_has_metric(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.base_color_matrix_metrics_insert(self, *args)

    def get_metric(self, *args):
        return _py_interop_metrics.base_color_matrix_metrics_get_metric(self, *args)

    def at(self, n):
        return _py_interop_metrics.base_color_matrix_metrics_at(self, n)

    def set_version(self, version):
        return _py_interop_metrics.base_color_matrix_metrics_set_version(self, version)

    def keys(self):
        return _py_interop_metrics.base_color_matrix_metrics_keys(self)

    def lanes(self):
        return _py_interop_metrics.base_color_matrix_metrics_lanes(self)

    def lane_count(self):
        return _py_interop_metrics.base_color_matrix_metrics_lane_count(self)

    def max_lane(self):
        return _py_interop_metrics.base_color_matrix_metrics_max_lane(self)

    def tile_numbers_for_lane(self, lane):
        return _py_interop_metrics.base_color_matrix_metrics_tile_numbers_for_lane(self, lane)

    def tile_numbers(self):
        return _py_interop_metrics.base_color_matrix_metrics_tile_numbers(self)

    def metrics_for_lane(self, *args):
        return _py_interop_metrics.base_color_matrix_metrics_metrics_for_lane(self, *args)

    def cycles(self):
        return _py_interop_metrics.base_color_matrix_metrics_cycles(self)

    def metrics_for_cycle(self, cycle):
        return _py_interop_metrics.base_color_matrix_metrics_metrics_for_cycle(self, cycle)

    def size(self):
        return _py_interop_metrics.base_color_matrix_metrics_size(self)

    def empty(self):
        return _py_interop_metrics.base_color_matrix_metrics_empty(self)

    def version(self):
        return _py_interop_metrics.base_color_matrix_metrics_version(self)

    def clear(self):
        return _py_interop_metrics.base_color_matrix_metrics_clear(self)

    def metrics(self):
        return _py_interop_metrics.base_color_matrix_metrics_metrics(self)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.base_color_matrix_metrics_prefix)
    else:
        prefix = _py_interop_metrics.base_color_matrix_metrics_prefix
    if _newclass:
        suffix = staticmethod(_py_interop_metrics.base_color_matrix_metrics_suffix)
    else:
        suffix = _py_interop_metrics.base_color_matrix_metrics_suffix

    def get_metric_ref(self, *args):
        return _py_interop_metrics.base_color_matrix_metrics_get_metric_ref(self, *args)
    __swig_destroy__ = _py_interop_metrics.delete_base_color_matrix_metrics
    __del__ = lambda self: None
base_color_matrix_metrics_swigregister = _py_interop_metrics.base_color_matrix_metrics_swigregister
base_color_matrix_metrics_swigregister(base_color_matrix_metrics)

def base_color_matrix_metrics_prefix():
    return _py_interop_metrics.base_color_matrix_metrics_prefix()
base_color_matrix_metrics_prefix = _py_interop_metrics.base_color_matrix_metrics_prefix

def base_color_matrix_metrics_suffix():
    return _py_interop_metrics.base_color_matrix_metrics_suffix()
base_color_matrix_metrics_suffix = _py_interop_metrics.base_color_matrix_metrics_suffix

class vector_color_matrix_metrics(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_color_matrix_metrics, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_color_matrix_metrics, name)
    __repr__ = _swig_repr
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _py_interop_metrics.vector_color_matrix_metrics___nonzero__(self)

    def __bool__(self):
        return _py_interop_metrics.vector_color_matrix_metrics___bool__(self)

    def __len__(self):
        return _py_interop_metrics.vector_color_matrix_metrics___len__(self)

    def __getslice__(self, i, j):
        return _py_interop_metrics.vector_color_matrix_metrics___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _py_interop_metrics.vector_color_matrix_metrics___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _py_interop_metrics.vector_color_matrix_metrics___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _py_interop_metrics.vector_color_matrix_metrics___delitem__(self, *args)

    def __getitem__(self, *args):
        return _py_interop_metrics.vector_color_matrix_metrics___getitem__(self, *args)

    def __setitem__(self, *args):
        return _py_interop_metrics.vector_color_matrix_metrics___setitem__(self, *args)

    def pop(self):
        return _py_interop_metrics.vector_color_matrix_metrics_pop(self)

    def append(self, x):
        return _py_interop_metrics.vector_color_matrix_metrics_append(self, x)

    def empty(self):
        return _py_interop_metrics.vector_color_matrix_metrics_empty(self)

    def size(self):
        return _py_interop_metrics.vector_color_matrix_metrics_size(self)

    def swap(self, v):
        return _py_interop_metrics.vector_color_matrix_metrics_swap(self, v)

    def rbegin(self):
        return _py_interop_metrics.vector_color_matrix_metrics_rbegin(self)

    def rend(self):
        return _py_interop_metrics.vector_color_matrix_metrics_rend(self)

    def clear(self):
        return _py_interop_metrics.vector_color_matrix_metrics_clear(self)

    def get_allocator(self):
        return _py_interop_metrics.vector_color_matrix_metrics_get_allocator(self)

    def pop_back(self):
        return _py_interop_metrics.vector_color_matrix_metrics_pop_back(self)

    def erase(self, *args):
        return _py_interop_metrics.vector_color_matrix_metrics_erase(self, *args)

    def __init__(self, *args):
        this = _py_interop_metrics.new_vector_color_matrix_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _py_interop_metrics.vector_color_matrix_metrics_push_back(self, x)

    def front(self):
        return _py_interop_metrics.vector_color_matrix_metrics_front(self)

    def back(self):
        return _py_interop_metrics.vector_color_matrix_metrics_back(self)

    def assign(self, n, x):
        return _py_interop_metrics.vector_color_matrix_metrics_assign(self, n, x)

    def resize(self, *args):
        return _py_interop_metrics.vector_color_matrix_metrics_resize(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.vector_color_matrix_metrics_insert(self, *args)

    def reserve(self, n):
        return _py_interop_metrics.vector_color_matrix_metrics_reserve(self, n)

    def capacity(self):
        return _py_interop_metrics.vector_color_matrix_metrics_capacity(self)
    __swig_destroy__ = _py_interop_metrics.delete_vector_color_matrix_metrics
    __del__ = lambda self: None
vector_color_matrix_metrics_swigregister = _py_interop_metrics.vector_color_matrix_metrics_swigregister
vector_color_matrix_metrics_swigregister(vector_color_matrix_metrics)

class base_distortion_metrics(distortion_metric_header):
    __swig_setmethods__ = {}
    for _s in [distortion_metric_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, base_distortion_metrics, name, value)
    __swig_getmethods__ = {}
    for _s in [distortion_metric_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, base_distortion_metrics, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.base_distortion_metrics_TYPE
    LATEST_VERSION = _py_interop_metrics.base_distortion_metrics_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_base_distortion_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def data_source_exists(self, *args):
        return _py_interop_metrics.base_distortion_metrics_data_source_exists(self, *args)

    def rebuild_index(self, update_ids=False):
        return _py_interop_metrics.base_distortion_metrics_rebuild_index(self, update_ids)

    def resize(self, n):
        return _py_interop_metrics.base_distortion_metrics_resize(self, n)

    def reserve(self, n):
        return _py_interop_metrics.base_distortion_metrics_reserve(self, n)

    def trim(self, n):
        return _py_interop_metrics.base_distortion_metrics_trim(self, n)

    def find(self, *args):
        return _py_interop_metrics.base_distortion_metrics_find(self, *args)

    def has_metric(self, *args):
        return _py_interop_metrics.base_distortion_metrics_has_metric(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.base_distortion_metrics_insert(self, *args)

    def get_metric(self, *args):
        return _py_interop_metrics.base_distortion_metrics_get_metric(self, *args)

    def at(self, n):
        return _py_interop_metrics.base_distortion_metrics_at(self, n)

    def set_version(self, version):
        return _py_interop_metrics.base_distortion_metrics_set_version(self, version)

    def keys(self):
        return _py_interop_metrics.base_distortion_metrics_keys(self)

    def lanes(self):
        return _py_interop_metrics.base_distortion_metrics_lanes(self)

    def lane_count(self):
        return _py_interop_metrics.base_distortion_metrics_lane_count(self)

    def max_lane(self):
        return _py_interop_metrics.base_distortion_metrics_max_lane(self)

    def tile_numbers_for_lane(self, lane):
        return _py_interop_metrics.base_distortion_metrics_tile_numbers_for_lane(self, lane)

    def tile_numbers(self):
        return _py_interop_metrics.base_distortion_metrics_tile_numbers(self)

    def metrics_for_lane(self, *args):
        return _py_interop_metrics.base_distortion_metrics_metrics_for_lane(self, *args)

    def cycles(self):
        return _py_interop_metrics.base_distortion_metrics_cycles(self)

    def metrics_for_cycle(self, cycle):
        return _py_interop_metrics.base_distortion_metrics_metrics_for_cycle(self, cycle)

    def size(self):
        return _py_interop_metrics.base_distortion_metrics_size(self)

    def empty(self):
        return _py_interop_metrics.base_distortion_metrics_empty(self)

    def version(self):
        return _py_interop_metrics.base_distortion_metrics_version(self)

    def clear(self):
        return _py_interop_metrics.base_distortion_metrics_clear(self)

    def metrics(self):
        return _py_interop_metrics.base_distortion_metrics_metrics(self)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.base_distortion_metrics_prefix)
    else:
        prefix = _py_interop_metrics.base_distortion_metrics_prefix
    if _newclass:
        suffix = staticmethod(_py_interop_metrics.base_distortion_metrics_suffix)
    else:
        suffix = _py_interop_metrics.base_distortion_metrics_suffix

    def get_metric_ref(self, *args):
        return _py_interop_metrics.base_distortion_metrics_get_metric_ref(self, *args)
    __swig_destroy__ = _py_interop_metrics.delete_base_distortion_metrics
    __del__ = lambda self: None
base_distortion_metrics_swigregister = _py_interop_metrics.base_distortion_metrics_swigregister
base_distortion_metrics_swigregister(base_distortion_metrics)

def base_distortion_metrics_prefix():
    return _py_interop_metrics.base_distortion_metrics_prefix()
base_distortion_metrics_prefix = _py_interop_metrics.base_distortion_metrics_prefix

def base_distortion_metrics_suffix():
    return _py_interop_metrics.base_distortion_metrics_suffix()
base_distortion_metrics_suffix = _py_interop_metrics.base_distortion_metrics_suffix

class vector_distortion_metrics(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_distortion_metrics, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_distortion_metrics, name)
    __repr__ = _swig_repr
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _py_interop_metrics.vector_distortion_metrics___nonzero__(self)

    def __bool__(self):
        return _py_interop_metrics.vector_distortion_metrics___bool__(self)

    def __len__(self):
        return _py_interop_metrics.vector_distortion_metrics___len__(self)

    def __getslice__(self, i, j):
        return _py_interop_metrics.vector_distortion_metrics___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _py_interop_metrics.vector_distortion_metrics___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _py_interop_metrics.vector_distortion_metrics___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _py_interop_metrics.vector_distortion_metrics___delitem__(self, *args)

    def __getitem__(self, *args):
        return _py_interop_metrics.vector_distortion_metrics___getitem__(self, *args)

    def __setitem__(self, *args):
        return _py_interop_metrics.vector_distortion_metrics___setitem__(self, *args)

    def pop(self):
        return _py_interop_metrics.vector_distortion_metrics_pop(self)

    def append(self, x):
        return _py_interop_metrics.vector_distortion_metrics_append(self, x)

    def empty(self):
        return _py_interop_metrics.vector_distortion_metrics_empty(self)

    def size(self):
        return _py_interop_metrics.vector_distortion_metrics_size(self)

    def swap(self, v):
        return _py_interop_metrics.vector_distortion_metrics_swap(self, v)

    def rbegin(self):
        return _py_interop_metrics.vector_distortion_metrics_rbegin(self)

    def rend(self):
        return _py_interop_metrics.vector_distortion_metrics_rend(self)

    def clear(self):
        return _py_interop_metrics.vector_distortion_metrics_clear(self)

    def get_allocator(self):
        return _py_interop_metrics.vector_distortion_metrics_get_allocator(self)

    def pop_back(self):
        return _py_interop_metrics.vector_distortion_metrics_pop_back(self)

    def erase(self, *args):
        return _py_interop_metrics.vector_distortion_metrics_erase(self, *args)

    def __init__(self, *args):
        this = _py_interop_metrics.new_vector_distortion_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _py_interop_metrics.vector_distortion_metrics_push_back(self, x)

    def front(self):
        return _py_interop_metrics.vector_distortion_metrics_front(self)

    def back(self):
        return _py_interop_metrics.vector_distortion_metrics_back(self)

    def assign(self, n, x):
        return _py_interop_metrics.vector_distortion_metrics_assign(self, n, x)

    def resize(self, *args):
        return _py_interop_metrics.vector_distortion_metrics_resize(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.vector_distortion_metrics_insert(self, *args)

    def reserve(self, n):
        return _py_interop_metrics.vector_distortion_metrics_reserve(self, n)

    def capacity(self):
        return _py_interop_metrics.vector_distortion_metrics_capacity(self)
    __swig_destroy__ = _py_interop_metrics.delete_vector_distortion_metrics
    __del__ = lambda self: None
vector_distortion_metrics_swigregister = _py_interop_metrics.vector_distortion_metrics_swigregister
vector_distortion_metrics_swigregister(vector_distortion_metrics)

class base_dynamic_phasing_metrics(base_read_metric_header):
    __swig_setmethods__ = {}
    for _s in [base_read_metric_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, base_dynamic_phasing_metrics, name, value)
    __swig_getmethods__ = {}
    for _s in [base_read_metric_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, base_dynamic_phasing_metrics, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.base_dynamic_phasing_metrics_TYPE
    LATEST_VERSION = _py_interop_metrics.base_dynamic_phasing_metrics_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_base_dynamic_phasing_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def data_source_exists(self, *args):
        return _py_interop_metrics.base_dynamic_phasing_metrics_data_source_exists(self, *args)

    def rebuild_index(self, update_ids=False):
        return _py_interop_metrics.base_dynamic_phasing_metrics_rebuild_index(self, update_ids)

    def resize(self, n):
        return _py_interop_metrics.base_dynamic_phasing_metrics_resize(self, n)

    def reserve(self, n):
        return _py_interop_metrics.base_dynamic_phasing_metrics_reserve(self, n)

    def trim(self, n):
        return _py_interop_metrics.base_dynamic_phasing_metrics_trim(self, n)

    def find(self, *args):
        return _py_interop_metrics.base_dynamic_phasing_metrics_find(self, *args)

    def has_metric(self, *args):
        return _py_interop_metrics.base_dynamic_phasing_metrics_has_metric(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.base_dynamic_phasing_metrics_insert(self, *args)

    def get_metric(self, *args):
        return _py_interop_metrics.base_dynamic_phasing_metrics_get_metric(self, *args)

    def at(self, n):
        return _py_interop_metrics.base_dynamic_phasing_metrics_at(self, n)

    def set_version(self, version):
        return _py_interop_metrics.base_dynamic_phasing_metrics_set_version(self, version)

    def keys(self):
        return _py_interop_metrics.base_dynamic_phasing_metrics_keys(self)

    def lanes(self):
        return _py_interop_metrics.base_dynamic_phasing_metrics_lanes(self)

    def lane_count(self):
        return _py_interop_metrics.base_dynamic_phasing_metrics_lane_count(self)

    def max_lane(self):
        return _py_interop_metrics.base_dynamic_phasing_metrics_max_lane(self)

    def tile_numbers_for_lane(self, lane):
        return _py_interop_metrics.base_dynamic_phasing_metrics_tile_numbers_for_lane(self, lane)

    def tile_numbers(self):
        return _py_interop_metrics.base_dynamic_phasing_metrics_tile_numbers(self)

    def metrics_for_lane(self, *args):
        return _py_interop_metrics.base_dynamic_phasing_metrics_metrics_for_lane(self, *args)

    def cycles(self):
        return _py_interop_metrics.base_dynamic_phasing_metrics_cycles(self)

    def metrics_for_cycle(self, cycle):
        return _py_interop_metrics.base_dynamic_phasing_metrics_metrics_for_cycle(self, cycle)

    def size(self):
        return _py_interop_metrics.base_dynamic_phasing_metrics_size(self)

    def empty(self):
        return _py_interop_metrics.base_dynamic_phasing_metrics_empty(self)

    def version(self):
        return _py_interop_metrics.base_dynamic_phasing_metrics_version(self)

    def clear(self):
        return _py_interop_metrics.base_dynamic_phasing_metrics_clear(self)

    def metrics(self):
        return _py_interop_metrics.base_dynamic_phasing_metrics_metrics(self)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.base_dynamic_phasing_metrics_prefix)
    else:
        prefix = _py_interop_metrics.base_dynamic_phasing_metrics_prefix
    if _newclass:
        suffix = staticmethod(_py_interop_metrics.base_dynamic_phasing_metrics_suffix)
    else:
        suffix = _py_interop_metrics.base_dynamic_phasing_metrics_suffix

    def get_metric_ref(self, *args):
        return _py_interop_metrics.base_dynamic_phasing_metrics_get_metric_ref(self, *args)
    __swig_destroy__ = _py_interop_metrics.delete_base_dynamic_phasing_metrics
    __del__ = lambda self: None
base_dynamic_phasing_metrics_swigregister = _py_interop_metrics.base_dynamic_phasing_metrics_swigregister
base_dynamic_phasing_metrics_swigregister(base_dynamic_phasing_metrics)

def base_dynamic_phasing_metrics_prefix():
    return _py_interop_metrics.base_dynamic_phasing_metrics_prefix()
base_dynamic_phasing_metrics_prefix = _py_interop_metrics.base_dynamic_phasing_metrics_prefix

def base_dynamic_phasing_metrics_suffix():
    return _py_interop_metrics.base_dynamic_phasing_metrics_suffix()
base_dynamic_phasing_metrics_suffix = _py_interop_metrics.base_dynamic_phasing_metrics_suffix

class vector_dynamic_phasing_metrics(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_dynamic_phasing_metrics, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_dynamic_phasing_metrics, name)
    __repr__ = _swig_repr
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _py_interop_metrics.vector_dynamic_phasing_metrics___nonzero__(self)

    def __bool__(self):
        return _py_interop_metrics.vector_dynamic_phasing_metrics___bool__(self)

    def __len__(self):
        return _py_interop_metrics.vector_dynamic_phasing_metrics___len__(self)

    def __getslice__(self, i, j):
        return _py_interop_metrics.vector_dynamic_phasing_metrics___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _py_interop_metrics.vector_dynamic_phasing_metrics___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _py_interop_metrics.vector_dynamic_phasing_metrics___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _py_interop_metrics.vector_dynamic_phasing_metrics___delitem__(self, *args)

    def __getitem__(self, *args):
        return _py_interop_metrics.vector_dynamic_phasing_metrics___getitem__(self, *args)

    def __setitem__(self, *args):
        return _py_interop_metrics.vector_dynamic_phasing_metrics___setitem__(self, *args)

    def pop(self):
        return _py_interop_metrics.vector_dynamic_phasing_metrics_pop(self)

    def append(self, x):
        return _py_interop_metrics.vector_dynamic_phasing_metrics_append(self, x)

    def empty(self):
        return _py_interop_metrics.vector_dynamic_phasing_metrics_empty(self)

    def size(self):
        return _py_interop_metrics.vector_dynamic_phasing_metrics_size(self)

    def swap(self, v):
        return _py_interop_metrics.vector_dynamic_phasing_metrics_swap(self, v)

    def rbegin(self):
        return _py_interop_metrics.vector_dynamic_phasing_metrics_rbegin(self)

    def rend(self):
        return _py_interop_metrics.vector_dynamic_phasing_metrics_rend(self)

    def clear(self):
        return _py_interop_metrics.vector_dynamic_phasing_metrics_clear(self)

    def get_allocator(self):
        return _py_interop_metrics.vector_dynamic_phasing_metrics_get_allocator(self)

    def pop_back(self):
        return _py_interop_metrics.vector_dynamic_phasing_metrics_pop_back(self)

    def erase(self, *args):
        return _py_interop_metrics.vector_dynamic_phasing_metrics_erase(self, *args)

    def __init__(self, *args):
        this = _py_interop_metrics.new_vector_dynamic_phasing_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _py_interop_metrics.vector_dynamic_phasing_metrics_push_back(self, x)

    def front(self):
        return _py_interop_metrics.vector_dynamic_phasing_metrics_front(self)

    def back(self):
        return _py_interop_metrics.vector_dynamic_phasing_metrics_back(self)

    def assign(self, n, x):
        return _py_interop_metrics.vector_dynamic_phasing_metrics_assign(self, n, x)

    def resize(self, *args):
        return _py_interop_metrics.vector_dynamic_phasing_metrics_resize(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.vector_dynamic_phasing_metrics_insert(self, *args)

    def reserve(self, n):
        return _py_interop_metrics.vector_dynamic_phasing_metrics_reserve(self, n)

    def capacity(self):
        return _py_interop_metrics.vector_dynamic_phasing_metrics_capacity(self)
    __swig_destroy__ = _py_interop_metrics.delete_vector_dynamic_phasing_metrics
    __del__ = lambda self: None
vector_dynamic_phasing_metrics_swigregister = _py_interop_metrics.vector_dynamic_phasing_metrics_swigregister
vector_dynamic_phasing_metrics_swigregister(vector_dynamic_phasing_metrics)

class base_event_metrics(base_event_metric_header):
    __swig_setmethods__ = {}
    for _s in [base_event_metric_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, base_event_metrics, name, value)
    __swig_getmethods__ = {}
    for _s in [base_event_metric_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, base_event_metrics, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.base_event_metrics_TYPE
    LATEST_VERSION = _py_interop_metrics.base_event_metrics_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_base_event_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def data_source_exists(self, *args):
        return _py_interop_metrics.base_event_metrics_data_source_exists(self, *args)

    def rebuild_index(self, update_ids=False):
        return _py_interop_metrics.base_event_metrics_rebuild_index(self, update_ids)

    def resize(self, n):
        return _py_interop_metrics.base_event_metrics_resize(self, n)

    def reserve(self, n):
        return _py_interop_metrics.base_event_metrics_reserve(self, n)

    def trim(self, n):
        return _py_interop_metrics.base_event_metrics_trim(self, n)

    def find(self, *args):
        return _py_interop_metrics.base_event_metrics_find(self, *args)

    def has_metric(self, *args):
        return _py_interop_metrics.base_event_metrics_has_metric(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.base_event_metrics_insert(self, *args)

    def get_metric(self, *args):
        return _py_interop_metrics.base_event_metrics_get_metric(self, *args)

    def at(self, n):
        return _py_interop_metrics.base_event_metrics_at(self, n)

    def set_version(self, version):
        return _py_interop_metrics.base_event_metrics_set_version(self, version)

    def keys(self):
        return _py_interop_metrics.base_event_metrics_keys(self)

    def lanes(self):
        return _py_interop_metrics.base_event_metrics_lanes(self)

    def lane_count(self):
        return _py_interop_metrics.base_event_metrics_lane_count(self)

    def max_lane(self):
        return _py_interop_metrics.base_event_metrics_max_lane(self)

    def tile_numbers_for_lane(self, lane):
        return _py_interop_metrics.base_event_metrics_tile_numbers_for_lane(self, lane)

    def tile_numbers(self):
        return _py_interop_metrics.base_event_metrics_tile_numbers(self)

    def metrics_for_lane(self, *args):
        return _py_interop_metrics.base_event_metrics_metrics_for_lane(self, *args)

    def cycles(self):
        return _py_interop_metrics.base_event_metrics_cycles(self)

    def metrics_for_cycle(self, cycle):
        return _py_interop_metrics.base_event_metrics_metrics_for_cycle(self, cycle)

    def size(self):
        return _py_interop_metrics.base_event_metrics_size(self)

    def empty(self):
        return _py_interop_metrics.base_event_metrics_empty(self)

    def version(self):
        return _py_interop_metrics.base_event_metrics_version(self)

    def clear(self):
        return _py_interop_metrics.base_event_metrics_clear(self)

    def metrics(self):
        return _py_interop_metrics.base_event_metrics_metrics(self)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.base_event_metrics_prefix)
    else:
        prefix = _py_interop_metrics.base_event_metrics_prefix
    if _newclass:
        suffix = staticmethod(_py_interop_metrics.base_event_metrics_suffix)
    else:
        suffix = _py_interop_metrics.base_event_metrics_suffix

    def get_metric_ref(self, *args):
        return _py_interop_metrics.base_event_metrics_get_metric_ref(self, *args)
    __swig_destroy__ = _py_interop_metrics.delete_base_event_metrics
    __del__ = lambda self: None
base_event_metrics_swigregister = _py_interop_metrics.base_event_metrics_swigregister
base_event_metrics_swigregister(base_event_metrics)

def base_event_metrics_prefix():
    return _py_interop_metrics.base_event_metrics_prefix()
base_event_metrics_prefix = _py_interop_metrics.base_event_metrics_prefix

def base_event_metrics_suffix():
    return _py_interop_metrics.base_event_metrics_suffix()
base_event_metrics_suffix = _py_interop_metrics.base_event_metrics_suffix

class vector_event_metrics(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_event_metrics, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_event_metrics, name)
    __repr__ = _swig_repr
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _py_interop_metrics.vector_event_metrics___nonzero__(self)

    def __bool__(self):
        return _py_interop_metrics.vector_event_metrics___bool__(self)

    def __len__(self):
        return _py_interop_metrics.vector_event_metrics___len__(self)

    def __getslice__(self, i, j):
        return _py_interop_metrics.vector_event_metrics___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _py_interop_metrics.vector_event_metrics___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _py_interop_metrics.vector_event_metrics___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _py_interop_metrics.vector_event_metrics___delitem__(self, *args)

    def __getitem__(self, *args):
        return _py_interop_metrics.vector_event_metrics___getitem__(self, *args)

    def __setitem__(self, *args):
        return _py_interop_metrics.vector_event_metrics___setitem__(self, *args)

    def pop(self):
        return _py_interop_metrics.vector_event_metrics_pop(self)

    def append(self, x):
        return _py_interop_metrics.vector_event_metrics_append(self, x)

    def empty(self):
        return _py_interop_metrics.vector_event_metrics_empty(self)

    def size(self):
        return _py_interop_metrics.vector_event_metrics_size(self)

    def swap(self, v):
        return _py_interop_metrics.vector_event_metrics_swap(self, v)

    def rbegin(self):
        return _py_interop_metrics.vector_event_metrics_rbegin(self)

    def rend(self):
        return _py_interop_metrics.vector_event_metrics_rend(self)

    def clear(self):
        return _py_interop_metrics.vector_event_metrics_clear(self)

    def get_allocator(self):
        return _py_interop_metrics.vector_event_metrics_get_allocator(self)

    def pop_back(self):
        return _py_interop_metrics.vector_event_metrics_pop_back(self)

    def erase(self, *args):
        return _py_interop_metrics.vector_event_metrics_erase(self, *args)

    def __init__(self, *args):
        this = _py_interop_metrics.new_vector_event_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _py_interop_metrics.vector_event_metrics_push_back(self, x)

    def front(self):
        return _py_interop_metrics.vector_event_metrics_front(self)

    def back(self):
        return _py_interop_metrics.vector_event_metrics_back(self)

    def assign(self, n, x):
        return _py_interop_metrics.vector_event_metrics_assign(self, n, x)

    def resize(self, *args):
        return _py_interop_metrics.vector_event_metrics_resize(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.vector_event_metrics_insert(self, *args)

    def reserve(self, n):
        return _py_interop_metrics.vector_event_metrics_reserve(self, n)

    def capacity(self):
        return _py_interop_metrics.vector_event_metrics_capacity(self)
    __swig_destroy__ = _py_interop_metrics.delete_vector_event_metrics
    __del__ = lambda self: None
vector_event_metrics_swigregister = _py_interop_metrics.vector_event_metrics_swigregister
vector_event_metrics_swigregister(vector_event_metrics)

class base_extended_tile_metrics(base_metric_header):
    __swig_setmethods__ = {}
    for _s in [base_metric_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, base_extended_tile_metrics, name, value)
    __swig_getmethods__ = {}
    for _s in [base_metric_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, base_extended_tile_metrics, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.base_extended_tile_metrics_TYPE
    LATEST_VERSION = _py_interop_metrics.base_extended_tile_metrics_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_base_extended_tile_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def data_source_exists(self, *args):
        return _py_interop_metrics.base_extended_tile_metrics_data_source_exists(self, *args)

    def rebuild_index(self, update_ids=False):
        return _py_interop_metrics.base_extended_tile_metrics_rebuild_index(self, update_ids)

    def resize(self, n):
        return _py_interop_metrics.base_extended_tile_metrics_resize(self, n)

    def reserve(self, n):
        return _py_interop_metrics.base_extended_tile_metrics_reserve(self, n)

    def trim(self, n):
        return _py_interop_metrics.base_extended_tile_metrics_trim(self, n)

    def find(self, *args):
        return _py_interop_metrics.base_extended_tile_metrics_find(self, *args)

    def has_metric(self, *args):
        return _py_interop_metrics.base_extended_tile_metrics_has_metric(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.base_extended_tile_metrics_insert(self, *args)

    def get_metric(self, *args):
        return _py_interop_metrics.base_extended_tile_metrics_get_metric(self, *args)

    def at(self, n):
        return _py_interop_metrics.base_extended_tile_metrics_at(self, n)

    def set_version(self, version):
        return _py_interop_metrics.base_extended_tile_metrics_set_version(self, version)

    def keys(self):
        return _py_interop_metrics.base_extended_tile_metrics_keys(self)

    def lanes(self):
        return _py_interop_metrics.base_extended_tile_metrics_lanes(self)

    def lane_count(self):
        return _py_interop_metrics.base_extended_tile_metrics_lane_count(self)

    def max_lane(self):
        return _py_interop_metrics.base_extended_tile_metrics_max_lane(self)

    def tile_numbers_for_lane(self, lane):
        return _py_interop_metrics.base_extended_tile_metrics_tile_numbers_for_lane(self, lane)

    def tile_numbers(self):
        return _py_interop_metrics.base_extended_tile_metrics_tile_numbers(self)

    def metrics_for_lane(self, *args):
        return _py_interop_metrics.base_extended_tile_metrics_metrics_for_lane(self, *args)

    def cycles(self):
        return _py_interop_metrics.base_extended_tile_metrics_cycles(self)

    def metrics_for_cycle(self, cycle):
        return _py_interop_metrics.base_extended_tile_metrics_metrics_for_cycle(self, cycle)

    def size(self):
        return _py_interop_metrics.base_extended_tile_metrics_size(self)

    def empty(self):
        return _py_interop_metrics.base_extended_tile_metrics_empty(self)

    def version(self):
        return _py_interop_metrics.base_extended_tile_metrics_version(self)

    def clear(self):
        return _py_interop_metrics.base_extended_tile_metrics_clear(self)

    def metrics(self):
        return _py_interop_metrics.base_extended_tile_metrics_metrics(self)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.base_extended_tile_metrics_prefix)
    else:
        prefix = _py_interop_metrics.base_extended_tile_metrics_prefix
    if _newclass:
        suffix = staticmethod(_py_interop_metrics.base_extended_tile_metrics_suffix)
    else:
        suffix = _py_interop_metrics.base_extended_tile_metrics_suffix

    def get_metric_ref(self, *args):
        return _py_interop_metrics.base_extended_tile_metrics_get_metric_ref(self, *args)
    __swig_destroy__ = _py_interop_metrics.delete_base_extended_tile_metrics
    __del__ = lambda self: None
base_extended_tile_metrics_swigregister = _py_interop_metrics.base_extended_tile_metrics_swigregister
base_extended_tile_metrics_swigregister(base_extended_tile_metrics)

def base_extended_tile_metrics_prefix():
    return _py_interop_metrics.base_extended_tile_metrics_prefix()
base_extended_tile_metrics_prefix = _py_interop_metrics.base_extended_tile_metrics_prefix

def base_extended_tile_metrics_suffix():
    return _py_interop_metrics.base_extended_tile_metrics_suffix()
base_extended_tile_metrics_suffix = _py_interop_metrics.base_extended_tile_metrics_suffix

class vector_extended_tile_metrics(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_extended_tile_metrics, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_extended_tile_metrics, name)
    __repr__ = _swig_repr
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _py_interop_metrics.vector_extended_tile_metrics___nonzero__(self)

    def __bool__(self):
        return _py_interop_metrics.vector_extended_tile_metrics___bool__(self)

    def __len__(self):
        return _py_interop_metrics.vector_extended_tile_metrics___len__(self)

    def __getslice__(self, i, j):
        return _py_interop_metrics.vector_extended_tile_metrics___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _py_interop_metrics.vector_extended_tile_metrics___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _py_interop_metrics.vector_extended_tile_metrics___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _py_interop_metrics.vector_extended_tile_metrics___delitem__(self, *args)

    def __getitem__(self, *args):
        return _py_interop_metrics.vector_extended_tile_metrics___getitem__(self, *args)

    def __setitem__(self, *args):
        return _py_interop_metrics.vector_extended_tile_metrics___setitem__(self, *args)

    def pop(self):
        return _py_interop_metrics.vector_extended_tile_metrics_pop(self)

    def append(self, x):
        return _py_interop_metrics.vector_extended_tile_metrics_append(self, x)

    def empty(self):
        return _py_interop_metrics.vector_extended_tile_metrics_empty(self)

    def size(self):
        return _py_interop_metrics.vector_extended_tile_metrics_size(self)

    def swap(self, v):
        return _py_interop_metrics.vector_extended_tile_metrics_swap(self, v)

    def rbegin(self):
        return _py_interop_metrics.vector_extended_tile_metrics_rbegin(self)

    def rend(self):
        return _py_interop_metrics.vector_extended_tile_metrics_rend(self)

    def clear(self):
        return _py_interop_metrics.vector_extended_tile_metrics_clear(self)

    def get_allocator(self):
        return _py_interop_metrics.vector_extended_tile_metrics_get_allocator(self)

    def pop_back(self):
        return _py_interop_metrics.vector_extended_tile_metrics_pop_back(self)

    def erase(self, *args):
        return _py_interop_metrics.vector_extended_tile_metrics_erase(self, *args)

    def __init__(self, *args):
        this = _py_interop_metrics.new_vector_extended_tile_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _py_interop_metrics.vector_extended_tile_metrics_push_back(self, x)

    def front(self):
        return _py_interop_metrics.vector_extended_tile_metrics_front(self)

    def back(self):
        return _py_interop_metrics.vector_extended_tile_metrics_back(self)

    def assign(self, n, x):
        return _py_interop_metrics.vector_extended_tile_metrics_assign(self, n, x)

    def resize(self, *args):
        return _py_interop_metrics.vector_extended_tile_metrics_resize(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.vector_extended_tile_metrics_insert(self, *args)

    def reserve(self, n):
        return _py_interop_metrics.vector_extended_tile_metrics_reserve(self, n)

    def capacity(self):
        return _py_interop_metrics.vector_extended_tile_metrics_capacity(self)
    __swig_destroy__ = _py_interop_metrics.delete_vector_extended_tile_metrics
    __del__ = lambda self: None
vector_extended_tile_metrics_swigregister = _py_interop_metrics.vector_extended_tile_metrics_swigregister
vector_extended_tile_metrics_swigregister(vector_extended_tile_metrics)

class base_fwhm_grid_metrics(fwhm_grid_metric_header):
    __swig_setmethods__ = {}
    for _s in [fwhm_grid_metric_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, base_fwhm_grid_metrics, name, value)
    __swig_getmethods__ = {}
    for _s in [fwhm_grid_metric_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, base_fwhm_grid_metrics, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.base_fwhm_grid_metrics_TYPE
    LATEST_VERSION = _py_interop_metrics.base_fwhm_grid_metrics_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_base_fwhm_grid_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def data_source_exists(self, *args):
        return _py_interop_metrics.base_fwhm_grid_metrics_data_source_exists(self, *args)

    def rebuild_index(self, update_ids=False):
        return _py_interop_metrics.base_fwhm_grid_metrics_rebuild_index(self, update_ids)

    def resize(self, n):
        return _py_interop_metrics.base_fwhm_grid_metrics_resize(self, n)

    def reserve(self, n):
        return _py_interop_metrics.base_fwhm_grid_metrics_reserve(self, n)

    def trim(self, n):
        return _py_interop_metrics.base_fwhm_grid_metrics_trim(self, n)

    def find(self, *args):
        return _py_interop_metrics.base_fwhm_grid_metrics_find(self, *args)

    def has_metric(self, *args):
        return _py_interop_metrics.base_fwhm_grid_metrics_has_metric(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.base_fwhm_grid_metrics_insert(self, *args)

    def get_metric(self, *args):
        return _py_interop_metrics.base_fwhm_grid_metrics_get_metric(self, *args)

    def at(self, n):
        return _py_interop_metrics.base_fwhm_grid_metrics_at(self, n)

    def set_version(self, version):
        return _py_interop_metrics.base_fwhm_grid_metrics_set_version(self, version)

    def keys(self):
        return _py_interop_metrics.base_fwhm_grid_metrics_keys(self)

    def lanes(self):
        return _py_interop_metrics.base_fwhm_grid_metrics_lanes(self)

    def lane_count(self):
        return _py_interop_metrics.base_fwhm_grid_metrics_lane_count(self)

    def max_lane(self):
        return _py_interop_metrics.base_fwhm_grid_metrics_max_lane(self)

    def tile_numbers_for_lane(self, lane):
        return _py_interop_metrics.base_fwhm_grid_metrics_tile_numbers_for_lane(self, lane)

    def tile_numbers(self):
        return _py_interop_metrics.base_fwhm_grid_metrics_tile_numbers(self)

    def metrics_for_lane(self, *args):
        return _py_interop_metrics.base_fwhm_grid_metrics_metrics_for_lane(self, *args)

    def cycles(self):
        return _py_interop_metrics.base_fwhm_grid_metrics_cycles(self)

    def metrics_for_cycle(self, cycle):
        return _py_interop_metrics.base_fwhm_grid_metrics_metrics_for_cycle(self, cycle)

    def size(self):
        return _py_interop_metrics.base_fwhm_grid_metrics_size(self)

    def empty(self):
        return _py_interop_metrics.base_fwhm_grid_metrics_empty(self)

    def version(self):
        return _py_interop_metrics.base_fwhm_grid_metrics_version(self)

    def clear(self):
        return _py_interop_metrics.base_fwhm_grid_metrics_clear(self)

    def metrics(self):
        return _py_interop_metrics.base_fwhm_grid_metrics_metrics(self)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.base_fwhm_grid_metrics_prefix)
    else:
        prefix = _py_interop_metrics.base_fwhm_grid_metrics_prefix
    if _newclass:
        suffix = staticmethod(_py_interop_metrics.base_fwhm_grid_metrics_suffix)
    else:
        suffix = _py_interop_metrics.base_fwhm_grid_metrics_suffix

    def get_metric_ref(self, *args):
        return _py_interop_metrics.base_fwhm_grid_metrics_get_metric_ref(self, *args)
    __swig_destroy__ = _py_interop_metrics.delete_base_fwhm_grid_metrics
    __del__ = lambda self: None
base_fwhm_grid_metrics_swigregister = _py_interop_metrics.base_fwhm_grid_metrics_swigregister
base_fwhm_grid_metrics_swigregister(base_fwhm_grid_metrics)

def base_fwhm_grid_metrics_prefix():
    return _py_interop_metrics.base_fwhm_grid_metrics_prefix()
base_fwhm_grid_metrics_prefix = _py_interop_metrics.base_fwhm_grid_metrics_prefix

def base_fwhm_grid_metrics_suffix():
    return _py_interop_metrics.base_fwhm_grid_metrics_suffix()
base_fwhm_grid_metrics_suffix = _py_interop_metrics.base_fwhm_grid_metrics_suffix

class vector_fwhm_grid_metrics(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_fwhm_grid_metrics, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_fwhm_grid_metrics, name)
    __repr__ = _swig_repr
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _py_interop_metrics.vector_fwhm_grid_metrics___nonzero__(self)

    def __bool__(self):
        return _py_interop_metrics.vector_fwhm_grid_metrics___bool__(self)

    def __len__(self):
        return _py_interop_metrics.vector_fwhm_grid_metrics___len__(self)

    def __getslice__(self, i, j):
        return _py_interop_metrics.vector_fwhm_grid_metrics___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _py_interop_metrics.vector_fwhm_grid_metrics___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _py_interop_metrics.vector_fwhm_grid_metrics___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _py_interop_metrics.vector_fwhm_grid_metrics___delitem__(self, *args)

    def __getitem__(self, *args):
        return _py_interop_metrics.vector_fwhm_grid_metrics___getitem__(self, *args)

    def __setitem__(self, *args):
        return _py_interop_metrics.vector_fwhm_grid_metrics___setitem__(self, *args)

    def pop(self):
        return _py_interop_metrics.vector_fwhm_grid_metrics_pop(self)

    def append(self, x):
        return _py_interop_metrics.vector_fwhm_grid_metrics_append(self, x)

    def empty(self):
        return _py_interop_metrics.vector_fwhm_grid_metrics_empty(self)

    def size(self):
        return _py_interop_metrics.vector_fwhm_grid_metrics_size(self)

    def swap(self, v):
        return _py_interop_metrics.vector_fwhm_grid_metrics_swap(self, v)

    def rbegin(self):
        return _py_interop_metrics.vector_fwhm_grid_metrics_rbegin(self)

    def rend(self):
        return _py_interop_metrics.vector_fwhm_grid_metrics_rend(self)

    def clear(self):
        return _py_interop_metrics.vector_fwhm_grid_metrics_clear(self)

    def get_allocator(self):
        return _py_interop_metrics.vector_fwhm_grid_metrics_get_allocator(self)

    def pop_back(self):
        return _py_interop_metrics.vector_fwhm_grid_metrics_pop_back(self)

    def erase(self, *args):
        return _py_interop_metrics.vector_fwhm_grid_metrics_erase(self, *args)

    def __init__(self, *args):
        this = _py_interop_metrics.new_vector_fwhm_grid_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _py_interop_metrics.vector_fwhm_grid_metrics_push_back(self, x)

    def front(self):
        return _py_interop_metrics.vector_fwhm_grid_metrics_front(self)

    def back(self):
        return _py_interop_metrics.vector_fwhm_grid_metrics_back(self)

    def assign(self, n, x):
        return _py_interop_metrics.vector_fwhm_grid_metrics_assign(self, n, x)

    def resize(self, *args):
        return _py_interop_metrics.vector_fwhm_grid_metrics_resize(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.vector_fwhm_grid_metrics_insert(self, *args)

    def reserve(self, n):
        return _py_interop_metrics.vector_fwhm_grid_metrics_reserve(self, n)

    def capacity(self):
        return _py_interop_metrics.vector_fwhm_grid_metrics_capacity(self)
    __swig_destroy__ = _py_interop_metrics.delete_vector_fwhm_grid_metrics
    __del__ = lambda self: None
vector_fwhm_grid_metrics_swigregister = _py_interop_metrics.vector_fwhm_grid_metrics_swigregister
vector_fwhm_grid_metrics_swigregister(vector_fwhm_grid_metrics)

class base_pf_grid_metrics(pf_grid_metric_header):
    __swig_setmethods__ = {}
    for _s in [pf_grid_metric_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, base_pf_grid_metrics, name, value)
    __swig_getmethods__ = {}
    for _s in [pf_grid_metric_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, base_pf_grid_metrics, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.base_pf_grid_metrics_TYPE
    LATEST_VERSION = _py_interop_metrics.base_pf_grid_metrics_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_base_pf_grid_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def data_source_exists(self, *args):
        return _py_interop_metrics.base_pf_grid_metrics_data_source_exists(self, *args)

    def rebuild_index(self, update_ids=False):
        return _py_interop_metrics.base_pf_grid_metrics_rebuild_index(self, update_ids)

    def resize(self, n):
        return _py_interop_metrics.base_pf_grid_metrics_resize(self, n)

    def reserve(self, n):
        return _py_interop_metrics.base_pf_grid_metrics_reserve(self, n)

    def trim(self, n):
        return _py_interop_metrics.base_pf_grid_metrics_trim(self, n)

    def find(self, *args):
        return _py_interop_metrics.base_pf_grid_metrics_find(self, *args)

    def has_metric(self, *args):
        return _py_interop_metrics.base_pf_grid_metrics_has_metric(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.base_pf_grid_metrics_insert(self, *args)

    def get_metric(self, *args):
        return _py_interop_metrics.base_pf_grid_metrics_get_metric(self, *args)

    def at(self, n):
        return _py_interop_metrics.base_pf_grid_metrics_at(self, n)

    def set_version(self, version):
        return _py_interop_metrics.base_pf_grid_metrics_set_version(self, version)

    def keys(self):
        return _py_interop_metrics.base_pf_grid_metrics_keys(self)

    def lanes(self):
        return _py_interop_metrics.base_pf_grid_metrics_lanes(self)

    def lane_count(self):
        return _py_interop_metrics.base_pf_grid_metrics_lane_count(self)

    def max_lane(self):
        return _py_interop_metrics.base_pf_grid_metrics_max_lane(self)

    def tile_numbers_for_lane(self, lane):
        return _py_interop_metrics.base_pf_grid_metrics_tile_numbers_for_lane(self, lane)

    def tile_numbers(self):
        return _py_interop_metrics.base_pf_grid_metrics_tile_numbers(self)

    def metrics_for_lane(self, *args):
        return _py_interop_metrics.base_pf_grid_metrics_metrics_for_lane(self, *args)

    def cycles(self):
        return _py_interop_metrics.base_pf_grid_metrics_cycles(self)

    def metrics_for_cycle(self, cycle):
        return _py_interop_metrics.base_pf_grid_metrics_metrics_for_cycle(self, cycle)

    def size(self):
        return _py_interop_metrics.base_pf_grid_metrics_size(self)

    def empty(self):
        return _py_interop_metrics.base_pf_grid_metrics_empty(self)

    def version(self):
        return _py_interop_metrics.base_pf_grid_metrics_version(self)

    def clear(self):
        return _py_interop_metrics.base_pf_grid_metrics_clear(self)

    def metrics(self):
        return _py_interop_metrics.base_pf_grid_metrics_metrics(self)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.base_pf_grid_metrics_prefix)
    else:
        prefix = _py_interop_metrics.base_pf_grid_metrics_prefix
    if _newclass:
        suffix = staticmethod(_py_interop_metrics.base_pf_grid_metrics_suffix)
    else:
        suffix = _py_interop_metrics.base_pf_grid_metrics_suffix

    def get_metric_ref(self, *args):
        return _py_interop_metrics.base_pf_grid_metrics_get_metric_ref(self, *args)
    __swig_destroy__ = _py_interop_metrics.delete_base_pf_grid_metrics
    __del__ = lambda self: None
base_pf_grid_metrics_swigregister = _py_interop_metrics.base_pf_grid_metrics_swigregister
base_pf_grid_metrics_swigregister(base_pf_grid_metrics)

def base_pf_grid_metrics_prefix():
    return _py_interop_metrics.base_pf_grid_metrics_prefix()
base_pf_grid_metrics_prefix = _py_interop_metrics.base_pf_grid_metrics_prefix

def base_pf_grid_metrics_suffix():
    return _py_interop_metrics.base_pf_grid_metrics_suffix()
base_pf_grid_metrics_suffix = _py_interop_metrics.base_pf_grid_metrics_suffix

class vector_pf_grid_metrics(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_pf_grid_metrics, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_pf_grid_metrics, name)
    __repr__ = _swig_repr
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _py_interop_metrics.vector_pf_grid_metrics___nonzero__(self)

    def __bool__(self):
        return _py_interop_metrics.vector_pf_grid_metrics___bool__(self)

    def __len__(self):
        return _py_interop_metrics.vector_pf_grid_metrics___len__(self)

    def __getslice__(self, i, j):
        return _py_interop_metrics.vector_pf_grid_metrics___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _py_interop_metrics.vector_pf_grid_metrics___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _py_interop_metrics.vector_pf_grid_metrics___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _py_interop_metrics.vector_pf_grid_metrics___delitem__(self, *args)

    def __getitem__(self, *args):
        return _py_interop_metrics.vector_pf_grid_metrics___getitem__(self, *args)

    def __setitem__(self, *args):
        return _py_interop_metrics.vector_pf_grid_metrics___setitem__(self, *args)

    def pop(self):
        return _py_interop_metrics.vector_pf_grid_metrics_pop(self)

    def append(self, x):
        return _py_interop_metrics.vector_pf_grid_metrics_append(self, x)

    def empty(self):
        return _py_interop_metrics.vector_pf_grid_metrics_empty(self)

    def size(self):
        return _py_interop_metrics.vector_pf_grid_metrics_size(self)

    def swap(self, v):
        return _py_interop_metrics.vector_pf_grid_metrics_swap(self, v)

    def rbegin(self):
        return _py_interop_metrics.vector_pf_grid_metrics_rbegin(self)

    def rend(self):
        return _py_interop_metrics.vector_pf_grid_metrics_rend(self)

    def clear(self):
        return _py_interop_metrics.vector_pf_grid_metrics_clear(self)

    def get_allocator(self):
        return _py_interop_metrics.vector_pf_grid_metrics_get_allocator(self)

    def pop_back(self):
        return _py_interop_metrics.vector_pf_grid_metrics_pop_back(self)

    def erase(self, *args):
        return _py_interop_metrics.vector_pf_grid_metrics_erase(self, *args)

    def __init__(self, *args):
        this = _py_interop_metrics.new_vector_pf_grid_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _py_interop_metrics.vector_pf_grid_metrics_push_back(self, x)

    def front(self):
        return _py_interop_metrics.vector_pf_grid_metrics_front(self)

    def back(self):
        return _py_interop_metrics.vector_pf_grid_metrics_back(self)

    def assign(self, n, x):
        return _py_interop_metrics.vector_pf_grid_metrics_assign(self, n, x)

    def resize(self, *args):
        return _py_interop_metrics.vector_pf_grid_metrics_resize(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.vector_pf_grid_metrics_insert(self, *args)

    def reserve(self, n):
        return _py_interop_metrics.vector_pf_grid_metrics_reserve(self, n)

    def capacity(self):
        return _py_interop_metrics.vector_pf_grid_metrics_capacity(self)
    __swig_destroy__ = _py_interop_metrics.delete_vector_pf_grid_metrics
    __del__ = lambda self: None
vector_pf_grid_metrics_swigregister = _py_interop_metrics.vector_pf_grid_metrics_swigregister
vector_pf_grid_metrics_swigregister(vector_pf_grid_metrics)

class base_phasing_metrics(base_cycle_metric_header):
    __swig_setmethods__ = {}
    for _s in [base_cycle_metric_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, base_phasing_metrics, name, value)
    __swig_getmethods__ = {}
    for _s in [base_cycle_metric_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, base_phasing_metrics, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.base_phasing_metrics_TYPE
    LATEST_VERSION = _py_interop_metrics.base_phasing_metrics_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_base_phasing_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def data_source_exists(self, *args):
        return _py_interop_metrics.base_phasing_metrics_data_source_exists(self, *args)

    def rebuild_index(self, update_ids=False):
        return _py_interop_metrics.base_phasing_metrics_rebuild_index(self, update_ids)

    def resize(self, n):
        return _py_interop_metrics.base_phasing_metrics_resize(self, n)

    def reserve(self, n):
        return _py_interop_metrics.base_phasing_metrics_reserve(self, n)

    def trim(self, n):
        return _py_interop_metrics.base_phasing_metrics_trim(self, n)

    def find(self, *args):
        return _py_interop_metrics.base_phasing_metrics_find(self, *args)

    def has_metric(self, *args):
        return _py_interop_metrics.base_phasing_metrics_has_metric(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.base_phasing_metrics_insert(self, *args)

    def get_metric(self, *args):
        return _py_interop_metrics.base_phasing_metrics_get_metric(self, *args)

    def at(self, n):
        return _py_interop_metrics.base_phasing_metrics_at(self, n)

    def set_version(self, version):
        return _py_interop_metrics.base_phasing_metrics_set_version(self, version)

    def keys(self):
        return _py_interop_metrics.base_phasing_metrics_keys(self)

    def lanes(self):
        return _py_interop_metrics.base_phasing_metrics_lanes(self)

    def lane_count(self):
        return _py_interop_metrics.base_phasing_metrics_lane_count(self)

    def max_lane(self):
        return _py_interop_metrics.base_phasing_metrics_max_lane(self)

    def tile_numbers_for_lane(self, lane):
        return _py_interop_metrics.base_phasing_metrics_tile_numbers_for_lane(self, lane)

    def tile_numbers(self):
        return _py_interop_metrics.base_phasing_metrics_tile_numbers(self)

    def metrics_for_lane(self, *args):
        return _py_interop_metrics.base_phasing_metrics_metrics_for_lane(self, *args)

    def cycles(self):
        return _py_interop_metrics.base_phasing_metrics_cycles(self)

    def metrics_for_cycle(self, cycle):
        return _py_interop_metrics.base_phasing_metrics_metrics_for_cycle(self, cycle)

    def size(self):
        return _py_interop_metrics.base_phasing_metrics_size(self)

    def empty(self):
        return _py_interop_metrics.base_phasing_metrics_empty(self)

    def version(self):
        return _py_interop_metrics.base_phasing_metrics_version(self)

    def clear(self):
        return _py_interop_metrics.base_phasing_metrics_clear(self)

    def metrics(self):
        return _py_interop_metrics.base_phasing_metrics_metrics(self)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.base_phasing_metrics_prefix)
    else:
        prefix = _py_interop_metrics.base_phasing_metrics_prefix
    if _newclass:
        suffix = staticmethod(_py_interop_metrics.base_phasing_metrics_suffix)
    else:
        suffix = _py_interop_metrics.base_phasing_metrics_suffix

    def get_metric_ref(self, *args):
        return _py_interop_metrics.base_phasing_metrics_get_metric_ref(self, *args)
    __swig_destroy__ = _py_interop_metrics.delete_base_phasing_metrics
    __del__ = lambda self: None
base_phasing_metrics_swigregister = _py_interop_metrics.base_phasing_metrics_swigregister
base_phasing_metrics_swigregister(base_phasing_metrics)

def base_phasing_metrics_prefix():
    return _py_interop_metrics.base_phasing_metrics_prefix()
base_phasing_metrics_prefix = _py_interop_metrics.base_phasing_metrics_prefix

def base_phasing_metrics_suffix():
    return _py_interop_metrics.base_phasing_metrics_suffix()
base_phasing_metrics_suffix = _py_interop_metrics.base_phasing_metrics_suffix

class vector_phasing_metrics(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_phasing_metrics, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_phasing_metrics, name)
    __repr__ = _swig_repr
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _py_interop_metrics.vector_phasing_metrics___nonzero__(self)

    def __bool__(self):
        return _py_interop_metrics.vector_phasing_metrics___bool__(self)

    def __len__(self):
        return _py_interop_metrics.vector_phasing_metrics___len__(self)

    def __getslice__(self, i, j):
        return _py_interop_metrics.vector_phasing_metrics___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _py_interop_metrics.vector_phasing_metrics___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _py_interop_metrics.vector_phasing_metrics___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _py_interop_metrics.vector_phasing_metrics___delitem__(self, *args)

    def __getitem__(self, *args):
        return _py_interop_metrics.vector_phasing_metrics___getitem__(self, *args)

    def __setitem__(self, *args):
        return _py_interop_metrics.vector_phasing_metrics___setitem__(self, *args)

    def pop(self):
        return _py_interop_metrics.vector_phasing_metrics_pop(self)

    def append(self, x):
        return _py_interop_metrics.vector_phasing_metrics_append(self, x)

    def empty(self):
        return _py_interop_metrics.vector_phasing_metrics_empty(self)

    def size(self):
        return _py_interop_metrics.vector_phasing_metrics_size(self)

    def swap(self, v):
        return _py_interop_metrics.vector_phasing_metrics_swap(self, v)

    def rbegin(self):
        return _py_interop_metrics.vector_phasing_metrics_rbegin(self)

    def rend(self):
        return _py_interop_metrics.vector_phasing_metrics_rend(self)

    def clear(self):
        return _py_interop_metrics.vector_phasing_metrics_clear(self)

    def get_allocator(self):
        return _py_interop_metrics.vector_phasing_metrics_get_allocator(self)

    def pop_back(self):
        return _py_interop_metrics.vector_phasing_metrics_pop_back(self)

    def erase(self, *args):
        return _py_interop_metrics.vector_phasing_metrics_erase(self, *args)

    def __init__(self, *args):
        this = _py_interop_metrics.new_vector_phasing_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _py_interop_metrics.vector_phasing_metrics_push_back(self, x)

    def front(self):
        return _py_interop_metrics.vector_phasing_metrics_front(self)

    def back(self):
        return _py_interop_metrics.vector_phasing_metrics_back(self)

    def assign(self, n, x):
        return _py_interop_metrics.vector_phasing_metrics_assign(self, n, x)

    def resize(self, *args):
        return _py_interop_metrics.vector_phasing_metrics_resize(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.vector_phasing_metrics_insert(self, *args)

    def reserve(self, n):
        return _py_interop_metrics.vector_phasing_metrics_reserve(self, n)

    def capacity(self):
        return _py_interop_metrics.vector_phasing_metrics_capacity(self)
    __swig_destroy__ = _py_interop_metrics.delete_vector_phasing_metrics
    __del__ = lambda self: None
vector_phasing_metrics_swigregister = _py_interop_metrics.vector_phasing_metrics_swigregister
vector_phasing_metrics_swigregister(vector_phasing_metrics)

class base_q_grid_metrics(q_grid_metric_header):
    __swig_setmethods__ = {}
    for _s in [q_grid_metric_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, base_q_grid_metrics, name, value)
    __swig_getmethods__ = {}
    for _s in [q_grid_metric_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, base_q_grid_metrics, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.base_q_grid_metrics_TYPE
    LATEST_VERSION = _py_interop_metrics.base_q_grid_metrics_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_base_q_grid_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def data_source_exists(self, *args):
        return _py_interop_metrics.base_q_grid_metrics_data_source_exists(self, *args)

    def rebuild_index(self, update_ids=False):
        return _py_interop_metrics.base_q_grid_metrics_rebuild_index(self, update_ids)

    def resize(self, n):
        return _py_interop_metrics.base_q_grid_metrics_resize(self, n)

    def reserve(self, n):
        return _py_interop_metrics.base_q_grid_metrics_reserve(self, n)

    def trim(self, n):
        return _py_interop_metrics.base_q_grid_metrics_trim(self, n)

    def find(self, *args):
        return _py_interop_metrics.base_q_grid_metrics_find(self, *args)

    def has_metric(self, *args):
        return _py_interop_metrics.base_q_grid_metrics_has_metric(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.base_q_grid_metrics_insert(self, *args)

    def get_metric(self, *args):
        return _py_interop_metrics.base_q_grid_metrics_get_metric(self, *args)

    def at(self, n):
        return _py_interop_metrics.base_q_grid_metrics_at(self, n)

    def set_version(self, version):
        return _py_interop_metrics.base_q_grid_metrics_set_version(self, version)

    def keys(self):
        return _py_interop_metrics.base_q_grid_metrics_keys(self)

    def lanes(self):
        return _py_interop_metrics.base_q_grid_metrics_lanes(self)

    def lane_count(self):
        return _py_interop_metrics.base_q_grid_metrics_lane_count(self)

    def max_lane(self):
        return _py_interop_metrics.base_q_grid_metrics_max_lane(self)

    def tile_numbers_for_lane(self, lane):
        return _py_interop_metrics.base_q_grid_metrics_tile_numbers_for_lane(self, lane)

    def tile_numbers(self):
        return _py_interop_metrics.base_q_grid_metrics_tile_numbers(self)

    def metrics_for_lane(self, *args):
        return _py_interop_metrics.base_q_grid_metrics_metrics_for_lane(self, *args)

    def cycles(self):
        return _py_interop_metrics.base_q_grid_metrics_cycles(self)

    def metrics_for_cycle(self, cycle):
        return _py_interop_metrics.base_q_grid_metrics_metrics_for_cycle(self, cycle)

    def size(self):
        return _py_interop_metrics.base_q_grid_metrics_size(self)

    def empty(self):
        return _py_interop_metrics.base_q_grid_metrics_empty(self)

    def version(self):
        return _py_interop_metrics.base_q_grid_metrics_version(self)

    def clear(self):
        return _py_interop_metrics.base_q_grid_metrics_clear(self)

    def metrics(self):
        return _py_interop_metrics.base_q_grid_metrics_metrics(self)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.base_q_grid_metrics_prefix)
    else:
        prefix = _py_interop_metrics.base_q_grid_metrics_prefix
    if _newclass:
        suffix = staticmethod(_py_interop_metrics.base_q_grid_metrics_suffix)
    else:
        suffix = _py_interop_metrics.base_q_grid_metrics_suffix

    def get_metric_ref(self, *args):
        return _py_interop_metrics.base_q_grid_metrics_get_metric_ref(self, *args)
    __swig_destroy__ = _py_interop_metrics.delete_base_q_grid_metrics
    __del__ = lambda self: None
base_q_grid_metrics_swigregister = _py_interop_metrics.base_q_grid_metrics_swigregister
base_q_grid_metrics_swigregister(base_q_grid_metrics)

def base_q_grid_metrics_prefix():
    return _py_interop_metrics.base_q_grid_metrics_prefix()
base_q_grid_metrics_prefix = _py_interop_metrics.base_q_grid_metrics_prefix

def base_q_grid_metrics_suffix():
    return _py_interop_metrics.base_q_grid_metrics_suffix()
base_q_grid_metrics_suffix = _py_interop_metrics.base_q_grid_metrics_suffix

class vector_q_grid_metrics(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_q_grid_metrics, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_q_grid_metrics, name)
    __repr__ = _swig_repr
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _py_interop_metrics.vector_q_grid_metrics___nonzero__(self)

    def __bool__(self):
        return _py_interop_metrics.vector_q_grid_metrics___bool__(self)

    def __len__(self):
        return _py_interop_metrics.vector_q_grid_metrics___len__(self)

    def __getslice__(self, i, j):
        return _py_interop_metrics.vector_q_grid_metrics___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _py_interop_metrics.vector_q_grid_metrics___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _py_interop_metrics.vector_q_grid_metrics___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _py_interop_metrics.vector_q_grid_metrics___delitem__(self, *args)

    def __getitem__(self, *args):
        return _py_interop_metrics.vector_q_grid_metrics___getitem__(self, *args)

    def __setitem__(self, *args):
        return _py_interop_metrics.vector_q_grid_metrics___setitem__(self, *args)

    def pop(self):
        return _py_interop_metrics.vector_q_grid_metrics_pop(self)

    def append(self, x):
        return _py_interop_metrics.vector_q_grid_metrics_append(self, x)

    def empty(self):
        return _py_interop_metrics.vector_q_grid_metrics_empty(self)

    def size(self):
        return _py_interop_metrics.vector_q_grid_metrics_size(self)

    def swap(self, v):
        return _py_interop_metrics.vector_q_grid_metrics_swap(self, v)

    def rbegin(self):
        return _py_interop_metrics.vector_q_grid_metrics_rbegin(self)

    def rend(self):
        return _py_interop_metrics.vector_q_grid_metrics_rend(self)

    def clear(self):
        return _py_interop_metrics.vector_q_grid_metrics_clear(self)

    def get_allocator(self):
        return _py_interop_metrics.vector_q_grid_metrics_get_allocator(self)

    def pop_back(self):
        return _py_interop_metrics.vector_q_grid_metrics_pop_back(self)

    def erase(self, *args):
        return _py_interop_metrics.vector_q_grid_metrics_erase(self, *args)

    def __init__(self, *args):
        this = _py_interop_metrics.new_vector_q_grid_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _py_interop_metrics.vector_q_grid_metrics_push_back(self, x)

    def front(self):
        return _py_interop_metrics.vector_q_grid_metrics_front(self)

    def back(self):
        return _py_interop_metrics.vector_q_grid_metrics_back(self)

    def assign(self, n, x):
        return _py_interop_metrics.vector_q_grid_metrics_assign(self, n, x)

    def resize(self, *args):
        return _py_interop_metrics.vector_q_grid_metrics_resize(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.vector_q_grid_metrics_insert(self, *args)

    def reserve(self, n):
        return _py_interop_metrics.vector_q_grid_metrics_reserve(self, n)

    def capacity(self):
        return _py_interop_metrics.vector_q_grid_metrics_capacity(self)
    __swig_destroy__ = _py_interop_metrics.delete_vector_q_grid_metrics
    __del__ = lambda self: None
vector_q_grid_metrics_swigregister = _py_interop_metrics.vector_q_grid_metrics_swigregister
vector_q_grid_metrics_swigregister(vector_q_grid_metrics)

class base_registration_metrics(registration_metric_header):
    __swig_setmethods__ = {}
    for _s in [registration_metric_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, base_registration_metrics, name, value)
    __swig_getmethods__ = {}
    for _s in [registration_metric_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, base_registration_metrics, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.base_registration_metrics_TYPE
    LATEST_VERSION = _py_interop_metrics.base_registration_metrics_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_base_registration_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def data_source_exists(self, *args):
        return _py_interop_metrics.base_registration_metrics_data_source_exists(self, *args)

    def rebuild_index(self, update_ids=False):
        return _py_interop_metrics.base_registration_metrics_rebuild_index(self, update_ids)

    def resize(self, n):
        return _py_interop_metrics.base_registration_metrics_resize(self, n)

    def reserve(self, n):
        return _py_interop_metrics.base_registration_metrics_reserve(self, n)

    def trim(self, n):
        return _py_interop_metrics.base_registration_metrics_trim(self, n)

    def find(self, *args):
        return _py_interop_metrics.base_registration_metrics_find(self, *args)

    def has_metric(self, *args):
        return _py_interop_metrics.base_registration_metrics_has_metric(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.base_registration_metrics_insert(self, *args)

    def get_metric(self, *args):
        return _py_interop_metrics.base_registration_metrics_get_metric(self, *args)

    def at(self, n):
        return _py_interop_metrics.base_registration_metrics_at(self, n)

    def set_version(self, version):
        return _py_interop_metrics.base_registration_metrics_set_version(self, version)

    def keys(self):
        return _py_interop_metrics.base_registration_metrics_keys(self)

    def lanes(self):
        return _py_interop_metrics.base_registration_metrics_lanes(self)

    def lane_count(self):
        return _py_interop_metrics.base_registration_metrics_lane_count(self)

    def max_lane(self):
        return _py_interop_metrics.base_registration_metrics_max_lane(self)

    def tile_numbers_for_lane(self, lane):
        return _py_interop_metrics.base_registration_metrics_tile_numbers_for_lane(self, lane)

    def tile_numbers(self):
        return _py_interop_metrics.base_registration_metrics_tile_numbers(self)

    def metrics_for_lane(self, *args):
        return _py_interop_metrics.base_registration_metrics_metrics_for_lane(self, *args)

    def cycles(self):
        return _py_interop_metrics.base_registration_metrics_cycles(self)

    def metrics_for_cycle(self, cycle):
        return _py_interop_metrics.base_registration_metrics_metrics_for_cycle(self, cycle)

    def size(self):
        return _py_interop_metrics.base_registration_metrics_size(self)

    def empty(self):
        return _py_interop_metrics.base_registration_metrics_empty(self)

    def version(self):
        return _py_interop_metrics.base_registration_metrics_version(self)

    def clear(self):
        return _py_interop_metrics.base_registration_metrics_clear(self)

    def metrics(self):
        return _py_interop_metrics.base_registration_metrics_metrics(self)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.base_registration_metrics_prefix)
    else:
        prefix = _py_interop_metrics.base_registration_metrics_prefix
    if _newclass:
        suffix = staticmethod(_py_interop_metrics.base_registration_metrics_suffix)
    else:
        suffix = _py_interop_metrics.base_registration_metrics_suffix

    def get_metric_ref(self, *args):
        return _py_interop_metrics.base_registration_metrics_get_metric_ref(self, *args)
    __swig_destroy__ = _py_interop_metrics.delete_base_registration_metrics
    __del__ = lambda self: None
base_registration_metrics_swigregister = _py_interop_metrics.base_registration_metrics_swigregister
base_registration_metrics_swigregister(base_registration_metrics)

def base_registration_metrics_prefix():
    return _py_interop_metrics.base_registration_metrics_prefix()
base_registration_metrics_prefix = _py_interop_metrics.base_registration_metrics_prefix

def base_registration_metrics_suffix():
    return _py_interop_metrics.base_registration_metrics_suffix()
base_registration_metrics_suffix = _py_interop_metrics.base_registration_metrics_suffix

class vector_registration_metrics(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_registration_metrics, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_registration_metrics, name)
    __repr__ = _swig_repr
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _py_interop_metrics.vector_registration_metrics___nonzero__(self)

    def __bool__(self):
        return _py_interop_metrics.vector_registration_metrics___bool__(self)

    def __len__(self):
        return _py_interop_metrics.vector_registration_metrics___len__(self)

    def __getslice__(self, i, j):
        return _py_interop_metrics.vector_registration_metrics___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _py_interop_metrics.vector_registration_metrics___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _py_interop_metrics.vector_registration_metrics___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _py_interop_metrics.vector_registration_metrics___delitem__(self, *args)

    def __getitem__(self, *args):
        return _py_interop_metrics.vector_registration_metrics___getitem__(self, *args)

    def __setitem__(self, *args):
        return _py_interop_metrics.vector_registration_metrics___setitem__(self, *args)

    def pop(self):
        return _py_interop_metrics.vector_registration_metrics_pop(self)

    def append(self, x):
        return _py_interop_metrics.vector_registration_metrics_append(self, x)

    def empty(self):
        return _py_interop_metrics.vector_registration_metrics_empty(self)

    def size(self):
        return _py_interop_metrics.vector_registration_metrics_size(self)

    def swap(self, v):
        return _py_interop_metrics.vector_registration_metrics_swap(self, v)

    def rbegin(self):
        return _py_interop_metrics.vector_registration_metrics_rbegin(self)

    def rend(self):
        return _py_interop_metrics.vector_registration_metrics_rend(self)

    def clear(self):
        return _py_interop_metrics.vector_registration_metrics_clear(self)

    def get_allocator(self):
        return _py_interop_metrics.vector_registration_metrics_get_allocator(self)

    def pop_back(self):
        return _py_interop_metrics.vector_registration_metrics_pop_back(self)

    def erase(self, *args):
        return _py_interop_metrics.vector_registration_metrics_erase(self, *args)

    def __init__(self, *args):
        this = _py_interop_metrics.new_vector_registration_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _py_interop_metrics.vector_registration_metrics_push_back(self, x)

    def front(self):
        return _py_interop_metrics.vector_registration_metrics_front(self)

    def back(self):
        return _py_interop_metrics.vector_registration_metrics_back(self)

    def assign(self, n, x):
        return _py_interop_metrics.vector_registration_metrics_assign(self, n, x)

    def resize(self, *args):
        return _py_interop_metrics.vector_registration_metrics_resize(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.vector_registration_metrics_insert(self, *args)

    def reserve(self, n):
        return _py_interop_metrics.vector_registration_metrics_reserve(self, n)

    def capacity(self):
        return _py_interop_metrics.vector_registration_metrics_capacity(self)
    __swig_destroy__ = _py_interop_metrics.delete_vector_registration_metrics
    __del__ = lambda self: None
vector_registration_metrics_swigregister = _py_interop_metrics.vector_registration_metrics_swigregister
vector_registration_metrics_swigregister(vector_registration_metrics)

class base_run_diagnostics_metrics(base_cycle_metric_header):
    __swig_setmethods__ = {}
    for _s in [base_cycle_metric_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, base_run_diagnostics_metrics, name, value)
    __swig_getmethods__ = {}
    for _s in [base_cycle_metric_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, base_run_diagnostics_metrics, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.base_run_diagnostics_metrics_TYPE
    LATEST_VERSION = _py_interop_metrics.base_run_diagnostics_metrics_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_base_run_diagnostics_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def data_source_exists(self, *args):
        return _py_interop_metrics.base_run_diagnostics_metrics_data_source_exists(self, *args)

    def rebuild_index(self, update_ids=False):
        return _py_interop_metrics.base_run_diagnostics_metrics_rebuild_index(self, update_ids)

    def resize(self, n):
        return _py_interop_metrics.base_run_diagnostics_metrics_resize(self, n)

    def reserve(self, n):
        return _py_interop_metrics.base_run_diagnostics_metrics_reserve(self, n)

    def trim(self, n):
        return _py_interop_metrics.base_run_diagnostics_metrics_trim(self, n)

    def find(self, *args):
        return _py_interop_metrics.base_run_diagnostics_metrics_find(self, *args)

    def has_metric(self, *args):
        return _py_interop_metrics.base_run_diagnostics_metrics_has_metric(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.base_run_diagnostics_metrics_insert(self, *args)

    def get_metric(self, *args):
        return _py_interop_metrics.base_run_diagnostics_metrics_get_metric(self, *args)

    def at(self, n):
        return _py_interop_metrics.base_run_diagnostics_metrics_at(self, n)

    def set_version(self, version):
        return _py_interop_metrics.base_run_diagnostics_metrics_set_version(self, version)

    def keys(self):
        return _py_interop_metrics.base_run_diagnostics_metrics_keys(self)

    def lanes(self):
        return _py_interop_metrics.base_run_diagnostics_metrics_lanes(self)

    def lane_count(self):
        return _py_interop_metrics.base_run_diagnostics_metrics_lane_count(self)

    def max_lane(self):
        return _py_interop_metrics.base_run_diagnostics_metrics_max_lane(self)

    def tile_numbers_for_lane(self, lane):
        return _py_interop_metrics.base_run_diagnostics_metrics_tile_numbers_for_lane(self, lane)

    def tile_numbers(self):
        return _py_interop_metrics.base_run_diagnostics_metrics_tile_numbers(self)

    def metrics_for_lane(self, *args):
        return _py_interop_metrics.base_run_diagnostics_metrics_metrics_for_lane(self, *args)

    def cycles(self):
        return _py_interop_metrics.base_run_diagnostics_metrics_cycles(self)

    def metrics_for_cycle(self, cycle):
        return _py_interop_metrics.base_run_diagnostics_metrics_metrics_for_cycle(self, cycle)

    def size(self):
        return _py_interop_metrics.base_run_diagnostics_metrics_size(self)

    def empty(self):
        return _py_interop_metrics.base_run_diagnostics_metrics_empty(self)

    def version(self):
        return _py_interop_metrics.base_run_diagnostics_metrics_version(self)

    def clear(self):
        return _py_interop_metrics.base_run_diagnostics_metrics_clear(self)

    def metrics(self):
        return _py_interop_metrics.base_run_diagnostics_metrics_metrics(self)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.base_run_diagnostics_metrics_prefix)
    else:
        prefix = _py_interop_metrics.base_run_diagnostics_metrics_prefix
    if _newclass:
        suffix = staticmethod(_py_interop_metrics.base_run_diagnostics_metrics_suffix)
    else:
        suffix = _py_interop_metrics.base_run_diagnostics_metrics_suffix

    def get_metric_ref(self, *args):
        return _py_interop_metrics.base_run_diagnostics_metrics_get_metric_ref(self, *args)
    __swig_destroy__ = _py_interop_metrics.delete_base_run_diagnostics_metrics
    __del__ = lambda self: None
base_run_diagnostics_metrics_swigregister = _py_interop_metrics.base_run_diagnostics_metrics_swigregister
base_run_diagnostics_metrics_swigregister(base_run_diagnostics_metrics)

def base_run_diagnostics_metrics_prefix():
    return _py_interop_metrics.base_run_diagnostics_metrics_prefix()
base_run_diagnostics_metrics_prefix = _py_interop_metrics.base_run_diagnostics_metrics_prefix

def base_run_diagnostics_metrics_suffix():
    return _py_interop_metrics.base_run_diagnostics_metrics_suffix()
base_run_diagnostics_metrics_suffix = _py_interop_metrics.base_run_diagnostics_metrics_suffix

class vector_run_diagnostics_metrics(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_run_diagnostics_metrics, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_run_diagnostics_metrics, name)
    __repr__ = _swig_repr
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _py_interop_metrics.vector_run_diagnostics_metrics___nonzero__(self)

    def __bool__(self):
        return _py_interop_metrics.vector_run_diagnostics_metrics___bool__(self)

    def __len__(self):
        return _py_interop_metrics.vector_run_diagnostics_metrics___len__(self)

    def __getslice__(self, i, j):
        return _py_interop_metrics.vector_run_diagnostics_metrics___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _py_interop_metrics.vector_run_diagnostics_metrics___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _py_interop_metrics.vector_run_diagnostics_metrics___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _py_interop_metrics.vector_run_diagnostics_metrics___delitem__(self, *args)

    def __getitem__(self, *args):
        return _py_interop_metrics.vector_run_diagnostics_metrics___getitem__(self, *args)

    def __setitem__(self, *args):
        return _py_interop_metrics.vector_run_diagnostics_metrics___setitem__(self, *args)

    def pop(self):
        return _py_interop_metrics.vector_run_diagnostics_metrics_pop(self)

    def append(self, x):
        return _py_interop_metrics.vector_run_diagnostics_metrics_append(self, x)

    def empty(self):
        return _py_interop_metrics.vector_run_diagnostics_metrics_empty(self)

    def size(self):
        return _py_interop_metrics.vector_run_diagnostics_metrics_size(self)

    def swap(self, v):
        return _py_interop_metrics.vector_run_diagnostics_metrics_swap(self, v)

    def rbegin(self):
        return _py_interop_metrics.vector_run_diagnostics_metrics_rbegin(self)

    def rend(self):
        return _py_interop_metrics.vector_run_diagnostics_metrics_rend(self)

    def clear(self):
        return _py_interop_metrics.vector_run_diagnostics_metrics_clear(self)

    def get_allocator(self):
        return _py_interop_metrics.vector_run_diagnostics_metrics_get_allocator(self)

    def pop_back(self):
        return _py_interop_metrics.vector_run_diagnostics_metrics_pop_back(self)

    def erase(self, *args):
        return _py_interop_metrics.vector_run_diagnostics_metrics_erase(self, *args)

    def __init__(self, *args):
        this = _py_interop_metrics.new_vector_run_diagnostics_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _py_interop_metrics.vector_run_diagnostics_metrics_push_back(self, x)

    def front(self):
        return _py_interop_metrics.vector_run_diagnostics_metrics_front(self)

    def back(self):
        return _py_interop_metrics.vector_run_diagnostics_metrics_back(self)

    def assign(self, n, x):
        return _py_interop_metrics.vector_run_diagnostics_metrics_assign(self, n, x)

    def resize(self, *args):
        return _py_interop_metrics.vector_run_diagnostics_metrics_resize(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.vector_run_diagnostics_metrics_insert(self, *args)

    def reserve(self, n):
        return _py_interop_metrics.vector_run_diagnostics_metrics_reserve(self, n)

    def capacity(self):
        return _py_interop_metrics.vector_run_diagnostics_metrics_capacity(self)
    __swig_destroy__ = _py_interop_metrics.delete_vector_run_diagnostics_metrics
    __del__ = lambda self: None
vector_run_diagnostics_metrics_swigregister = _py_interop_metrics.vector_run_diagnostics_metrics_swigregister
vector_run_diagnostics_metrics_swigregister(vector_run_diagnostics_metrics)

class base_static_run_metrics(static_run_metric_header):
    __swig_setmethods__ = {}
    for _s in [static_run_metric_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, base_static_run_metrics, name, value)
    __swig_getmethods__ = {}
    for _s in [static_run_metric_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, base_static_run_metrics, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.base_static_run_metrics_TYPE
    LATEST_VERSION = _py_interop_metrics.base_static_run_metrics_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_base_static_run_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def data_source_exists(self, *args):
        return _py_interop_metrics.base_static_run_metrics_data_source_exists(self, *args)

    def rebuild_index(self, update_ids=False):
        return _py_interop_metrics.base_static_run_metrics_rebuild_index(self, update_ids)

    def resize(self, n):
        return _py_interop_metrics.base_static_run_metrics_resize(self, n)

    def reserve(self, n):
        return _py_interop_metrics.base_static_run_metrics_reserve(self, n)

    def trim(self, n):
        return _py_interop_metrics.base_static_run_metrics_trim(self, n)

    def find(self, *args):
        return _py_interop_metrics.base_static_run_metrics_find(self, *args)

    def has_metric(self, *args):
        return _py_interop_metrics.base_static_run_metrics_has_metric(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.base_static_run_metrics_insert(self, *args)

    def get_metric(self, *args):
        return _py_interop_metrics.base_static_run_metrics_get_metric(self, *args)

    def at(self, n):
        return _py_interop_metrics.base_static_run_metrics_at(self, n)

    def set_version(self, version):
        return _py_interop_metrics.base_static_run_metrics_set_version(self, version)

    def keys(self):
        return _py_interop_metrics.base_static_run_metrics_keys(self)

    def lanes(self):
        return _py_interop_metrics.base_static_run_metrics_lanes(self)

    def lane_count(self):
        return _py_interop_metrics.base_static_run_metrics_lane_count(self)

    def max_lane(self):
        return _py_interop_metrics.base_static_run_metrics_max_lane(self)

    def tile_numbers_for_lane(self, lane):
        return _py_interop_metrics.base_static_run_metrics_tile_numbers_for_lane(self, lane)

    def tile_numbers(self):
        return _py_interop_metrics.base_static_run_metrics_tile_numbers(self)

    def metrics_for_lane(self, *args):
        return _py_interop_metrics.base_static_run_metrics_metrics_for_lane(self, *args)

    def cycles(self):
        return _py_interop_metrics.base_static_run_metrics_cycles(self)

    def metrics_for_cycle(self, cycle):
        return _py_interop_metrics.base_static_run_metrics_metrics_for_cycle(self, cycle)

    def size(self):
        return _py_interop_metrics.base_static_run_metrics_size(self)

    def empty(self):
        return _py_interop_metrics.base_static_run_metrics_empty(self)

    def version(self):
        return _py_interop_metrics.base_static_run_metrics_version(self)

    def clear(self):
        return _py_interop_metrics.base_static_run_metrics_clear(self)

    def metrics(self):
        return _py_interop_metrics.base_static_run_metrics_metrics(self)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.base_static_run_metrics_prefix)
    else:
        prefix = _py_interop_metrics.base_static_run_metrics_prefix
    if _newclass:
        suffix = staticmethod(_py_interop_metrics.base_static_run_metrics_suffix)
    else:
        suffix = _py_interop_metrics.base_static_run_metrics_suffix

    def get_metric_ref(self, *args):
        return _py_interop_metrics.base_static_run_metrics_get_metric_ref(self, *args)
    __swig_destroy__ = _py_interop_metrics.delete_base_static_run_metrics
    __del__ = lambda self: None
base_static_run_metrics_swigregister = _py_interop_metrics.base_static_run_metrics_swigregister
base_static_run_metrics_swigregister(base_static_run_metrics)

def base_static_run_metrics_prefix():
    return _py_interop_metrics.base_static_run_metrics_prefix()
base_static_run_metrics_prefix = _py_interop_metrics.base_static_run_metrics_prefix

def base_static_run_metrics_suffix():
    return _py_interop_metrics.base_static_run_metrics_suffix()
base_static_run_metrics_suffix = _py_interop_metrics.base_static_run_metrics_suffix

class vector_static_run_metrics(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_static_run_metrics, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_static_run_metrics, name)
    __repr__ = _swig_repr
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _py_interop_metrics.vector_static_run_metrics___nonzero__(self)

    def __bool__(self):
        return _py_interop_metrics.vector_static_run_metrics___bool__(self)

    def __len__(self):
        return _py_interop_metrics.vector_static_run_metrics___len__(self)

    def __getslice__(self, i, j):
        return _py_interop_metrics.vector_static_run_metrics___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _py_interop_metrics.vector_static_run_metrics___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _py_interop_metrics.vector_static_run_metrics___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _py_interop_metrics.vector_static_run_metrics___delitem__(self, *args)

    def __getitem__(self, *args):
        return _py_interop_metrics.vector_static_run_metrics___getitem__(self, *args)

    def __setitem__(self, *args):
        return _py_interop_metrics.vector_static_run_metrics___setitem__(self, *args)

    def pop(self):
        return _py_interop_metrics.vector_static_run_metrics_pop(self)

    def append(self, x):
        return _py_interop_metrics.vector_static_run_metrics_append(self, x)

    def empty(self):
        return _py_interop_metrics.vector_static_run_metrics_empty(self)

    def size(self):
        return _py_interop_metrics.vector_static_run_metrics_size(self)

    def swap(self, v):
        return _py_interop_metrics.vector_static_run_metrics_swap(self, v)

    def rbegin(self):
        return _py_interop_metrics.vector_static_run_metrics_rbegin(self)

    def rend(self):
        return _py_interop_metrics.vector_static_run_metrics_rend(self)

    def clear(self):
        return _py_interop_metrics.vector_static_run_metrics_clear(self)

    def get_allocator(self):
        return _py_interop_metrics.vector_static_run_metrics_get_allocator(self)

    def pop_back(self):
        return _py_interop_metrics.vector_static_run_metrics_pop_back(self)

    def erase(self, *args):
        return _py_interop_metrics.vector_static_run_metrics_erase(self, *args)

    def __init__(self, *args):
        this = _py_interop_metrics.new_vector_static_run_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _py_interop_metrics.vector_static_run_metrics_push_back(self, x)

    def front(self):
        return _py_interop_metrics.vector_static_run_metrics_front(self)

    def back(self):
        return _py_interop_metrics.vector_static_run_metrics_back(self)

    def assign(self, n, x):
        return _py_interop_metrics.vector_static_run_metrics_assign(self, n, x)

    def resize(self, *args):
        return _py_interop_metrics.vector_static_run_metrics_resize(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.vector_static_run_metrics_insert(self, *args)

    def reserve(self, n):
        return _py_interop_metrics.vector_static_run_metrics_reserve(self, n)

    def capacity(self):
        return _py_interop_metrics.vector_static_run_metrics_capacity(self)
    __swig_destroy__ = _py_interop_metrics.delete_vector_static_run_metrics
    __del__ = lambda self: None
vector_static_run_metrics_swigregister = _py_interop_metrics.vector_static_run_metrics_swigregister
vector_static_run_metrics_swigregister(vector_static_run_metrics)

# This file is compatible with both classic and new-style classes.


